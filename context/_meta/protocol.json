{
  "context_memory_protocol": {
    "version": "1.0",
    "last_updated": "2025-01-04",
    "purpose": "Persistent project knowledge base for strategic project management and development collaboration on archive software",
    
    "update_protocol": {
      "primary_approach": "amendment_and_evolution",
      "default_behavior": "Add new information with timestamps, preserve decision history",
      
      "when_to_amend": [
        "New requirements discovered",
        "Additional architectural decisions made", 
        "Deeper understanding of existing code patterns",
        "New technical debt identified",
        "Refined user workflow understanding",
        "API changes (internal vs public classification)",
        "Features affecting deployment modes"
      ],
      
      "when_to_revise": [
        "Erroneous information discovered",
        "Fundamental requirement changes",
        "Architectural pivots that invalidate previous decisions",
        "File consolidation needs when unwieldy"
      ],
      
      "entry_structure": {
        "decision_id": "unique_identifier",
        "content": "the actual information", 
        "added_date": "YYYY-MM-DD",
        "conversation_reference": "brief description of discussion context",
        "confidence_level": "high|medium|low",
        "status": "active|deprecated|under_review"
      },
      
      "revision_indicators": {
        "deprecation": "Mark old info as 'deprecated' rather than deleting",
        "supersession": "Add 'superseded_by' references to new decisions",
        "revision_reason": "Always include why information changed"
      }
    },
    
    "self_enforcement": {
      "built_in_triggers": [
        "Making architectural changes",
        "Discovering new requirements or constraints",
        "Completing significant refactoring", 
        "Making API changes",
        "Adding features affecting deployment modes",
        "Before ending conversations with decisions made"
      ],
      
      "conversation_end_checklist": [
        "What did we learn about requirements?",
        "What architectural decisions did we make?",
        "What code patterns did we establish?", 
        "What needs to be preserved going forward?",
        "Which context files need updates?"
      ],
      
      "decision_point_protocol": [
        "Check relevant context files before suggesting major changes",
        "Update files with decision rationale",
        "Confirm updates align with Project Manager understanding"
      ]
    },
    
    "quality_control": {
      "conflict_resolution": "When conflicts detected, immediately prompt Project Manager with specific conflict and request resolution guidance",
      "uncertainty_handling": "Flag uncertain information and request Project Manager confirmation before writing",
      "cross_reference_validation": "When updating one file, check if related files need updates",
      "reality_checks": "Flag when context seems inconsistent with current codebase"
    },
    
    "file_growth_management": {
      "size_triggers": {
        "line_count": 2000,
        "file_size": "150KB"
      },
      "splitting_protocol": [
        "Analyze file's logical sections",
        "Propose split based on natural boundaries, cross-reference frequency, usage patterns",
        "Get Project Manager approval before executing split",
        "Maintain proper cross-references after split"
      ]
    },
    
    "emergency_protocol": {
      "inconsistency_response": [
        "Stop all development work immediately",
        "Prompt Project Manager with specific inconsistency detected",
        "Provide severity assessment",
        "Propose recovery options",
        "Request guidance on resolution approach"
      ]
    },
    
    "commit_and_testing_protocol": {
      "decision_id": "protocol_005",
      "content": "Git commit guidelines requiring user validation and testing before commits",
      "added_date": "2025-01-04",
      "commit_approval_process": [
        "Complete development work for milestone/phase",
        "Build and verify functionality compiles",
        "VERIFY ADA compliance: axe-core passes, keyboard navigation works, screen reader compatible",
        "VERIFY responsive design: mobile-first approach, touch-friendly, cross-device tested",
        "ASK USER for testing/validation before committing",
        "Wait for user feedback and approval",
        "Only commit after user confirms testing is complete"
      ],
      "mandatory_user_involvement": [
        "User must test functionality before any commits",
        "User must approve commit timing and scope",
        "User validates that milestone/phase is truly complete",
        "User confirms readiness to proceed to next phase"
      ],
      "commit_guidelines": [
        "Never commit without explicit user validation first",
        "Ask for confirmation before making any commits",
        "Include user in testing loop for each milestone",
        "ENSURE ADA compliance and responsive design requirements are met",
        "Descriptive commit messages with clear scope",
        "Atomic commits for logical units of work",
        "Include testing status and user approval in commit message",
        "Reference context files when relevant"
      ],
      "message_format": "Brief summary\\n\\nDetailed changes:\\n- Feature 1\\n- Feature 2\\n\\nTested by: User validation completed\\nApproved by: Project Manager\\nNext: Planned next steps",
      "confidence_level": "high",
      "status": "active"
    },
    
    "stack_compliant_development_protocol": {
      "decision_id": "protocol_006",
      "content": "Protocol for handling user requests that conflict with framework/stack best practices",
      "added_date": "2025-10-14",
      "conversation_reference": "Dropdown layout issue debugging - learned to discuss alternatives before fighting framework behavior",
      
      "trigger_conditions": [
        "User request requires extensive CSS to override framework defaults",
        "Implementation would fight against framework's intended behavior",
        "Solution requires significant customization of third-party components",
        "Approach conflicts with documented best practices for React/MUI/Django stack",
        "Implementation would create technical debt or maintenance burden"
      ],
      
      "required_protocol_steps": [
        "STOP before implementing - do not make changes immediately",
        "ALERT the user to the conflict with stack best practices",
        "EXPLAIN why the request conflicts with framework patterns",
        "PROPOSE alternative approaches that achieve the same goal using stack-compliant methods",
        "DISCUSS trade-offs between approaches with full technical context",
        "ONLY PROCEED after user explicitly chooses approach with full understanding"
      ],
      
      "communication_template": {
        "alert_format": "This request conflicts with [Framework] best practices because [specific reason].",
        "alternative_proposal": "Alternative approach: [stack-compliant solution] - would this achieve your goal?",
        "trade_off_discussion": "Trade-offs: [approach A pros/cons] vs [approach B pros/cons]"
      },
      
      "example_scenarios": [
        "CSS fighting MUI component behavior (e.g., forcing Select truncation)",
        "Overriding React lifecycle patterns",
        "Bypassing Django's ORM or form validation",
        "Custom implementations of functionality already provided by framework",
        "Solutions requiring !important CSS or DOM manipulation"
      ],
      
      "benefits": [
        "Prevents technical debt from fighting frameworks",
        "Saves development time by avoiding failed approaches", 
        "Leverages combined expertise (user requirements + technical constraints)",
        "Often leads to better solutions through collaborative discussion",
        "Maintains code quality and maintainability"
      ],
      
      "success_example": {
        "scenario": "User requested dropdown text truncation to prevent card width expansion",
        "initial_approach": "Multiple CSS attempts to force MUI Select truncation (failed)",
        "protocol_application": "Should have immediately proposed dynamic text abbreviation using renderValue",
        "outcome": "Alternative solution achieved goal while working with MUI patterns",
        "lesson": "Framework-compliant solutions are often simpler and more robust"
      },
      
      "confidence_level": "high",
      "status": "active"
    },
    
    "end_user_documentation_protocol": {
      "decision_id": "protocol_007",
      "content": "Protocol for creating and maintaining end-user documentation (user guides and system behavior docs)",
      "added_date": "2025-10-29",
      "conversation_reference": "End-user documentation requirement discussion",
      
      "fundamental_rule": {
        "never_proactive": "Lead developers NEVER create or update end-user documentation proactively",
        "explicit_request_only": "Documentation work only proceeds when the Project Manager explicitly requests it",
        "rationale": "Documentation is a deliberate deliverable requiring Project Manager control over timing, scope, and quality"
      },
      
      "creation_protocol": {
        "trigger_phrases": [
          "Create user documentation for [feature/section]",
          "Write user guide for [workflow]",
          "Document system behavior for [component]",
          "Add end-user docs for [feature]"
        ],
        "required_clarifications": [
          "Which documentation type? (user guide vs system behavior)",
          "Which features/sections to cover?",
          "Target audience level? (beginner, intermediate, advanced)",
          "Include screenshots/diagrams?",
          "Cross-reference related sections?"
        ],
        "execution_steps": [
          "Confirm scope and audience with Project Manager",
          "Draft documentation in specified location (docs/user-guide/ or docs/system-behavior/)",
          "Include all required sections per documentation type",
          "Add cross-references to related documentation",
          "Present draft to Project Manager for review and approval",
          "Iterate based on Project Manager feedback"
        ]
      },
      
      "survey_protocol": {
        "trigger_phrases": [
          "Survey user documentation for accuracy",
          "Check if documentation is up to date",
          "Review end-user docs for completeness",
          "Audit system behavior documentation"
        ],
        "survey_types": {
          "accuracy_check": {
            "question": "Is existing documentation still correct given recent code changes?",
            "method": "Compare documented behavior against current codebase",
            "output": "List of inaccurate sections with specific discrepancies"
          },
          "completeness_check": {
            "question": "Are there new features missing from documentation?",
            "method": "Identify features implemented since last doc update",
            "output": "List of undocumented features with suggested sections"
          },
          "staleness_check": {
            "question": "Are there deprecated features still documented?",
            "method": "Identify documented features no longer in codebase",
            "output": "List of stale documentation sections to remove/update"
          }
        },
        "survey_output_format": {
          "structure": "Organized report by documentation section",
          "priority_levels": "Critical (breaks user workflow), High (misleading), Medium (outdated), Low (cosmetic)",
          "recommendations": "Specific suggested changes for each identified issue",
          "cross_impact": "Note if one change affects multiple documentation sections"
        },
        "execution_approval": {
          "never_automatic_updates": "Survey identifies issues but NEVER makes automatic updates",
          "pm_review_required": "Project Manager reviews survey results and approves specific changes",
          "incremental_updates": "Project Manager may approve updates incrementally by priority level"
        }
      },
      
      "documentation_types": {
        "user_guide": {
          "location": "docs/user-guide/",
          "audience": "Museum staff, archivists, researchers",
          "focus": "How to use the system - actions, workflows, procedures",
          "includes": "Screenshots, step-by-step instructions, role-specific guides",
          "excludes": "Code details, implementation specifics, technical architecture"
        },
        "system_behavior": {
          "location": "docs/system-behavior/",
          "audience": "Technical users, sysadmins, developers understanding internals",
          "focus": "How the system works - logic, algorithms, processing workflows",
          "includes": "Pseudocode, data flow diagrams, state transitions, business rules",
          "excludes": "UI navigation, user actions, deployment procedures",
          "style": "Similar to architectural clarifications during development"
        }
      },
      
      "quality_standards": {
        "user_guide_standards": [
          "Every user action must have clear step-by-step instructions",
          "Screenshots for complex UI interactions",
          "Common pitfalls and troubleshooting tips",
          "Role-specific callouts (Archivist-only, Museum Staff, etc.)",
          "Cross-references to related workflows"
        ],
        "system_behavior_standards": [
          "Pseudocode-level descriptions (not actual code)",
          "Clear state transitions and data flow",
          "Explicit assumptions and constraints",
          "Edge cases and error handling",
          "Cross-references to code files for implementation details"
        ],
        "general_standards": [
          "Clear, concise writing",
          "Organized by feature/task, not by code structure",
          "Table of contents for docs > 200 lines",
          "Date-stamped with last update",
          "Version-specific notes when relevant"
        ]
      },
      
      "integration_with_development": {
        "code_changes_triggering_surveys": [
          "New user-facing features added",
          "Existing features significantly modified",
          "User workflows changed",
          "Permissions or access control altered",
          "System behavior logic updated (signals, tasks, algorithms)"
        ],
        "conversation_end_checklist_addition": "Did we implement features requiring user documentation updates?",
        "proactive_flagging": "Lead developer may FLAG that documentation might need updates, but NEVER creates updates without explicit Project Manager request"
      },
      
      "benefits": [
        "User self-service reduces support burden",
        "Clear onboarding for new staff",
        "System behavior clarity for technical users",
        "Knowledge preservation as team changes",
        "Reduced ambiguity about system operations"
      ],
      
      "confidence_level": "high",
      "status": "active",
      "cross_references": ["project_requirements.json::end_user_documentation", "documentation_structure.json"]
    }
  }
}
