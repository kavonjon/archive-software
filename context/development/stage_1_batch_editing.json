{
  "stage_1_batch_editing": {
    "version": "7.0",
    "last_updated": "2025-11-11",
    "conversation_reference": "Detailed Stage 1 planning and implementation architecture for smart spreadsheet batch editing features. Version 7.0 adds list page improvements (filter persistence, selection indicators, improved filtering) and languoid list display enhancements (Items column with cache versioning).",
    
    "stage_overview": {
      "decision_id": "stage1_001",
      "content": "Sophisticated batch editing system with smart spreadsheet interface replacing current import functionality",
      "added_date": "2025-01-04",
      "updated_date": "2025-11-10",
      "strategic_importance": "Provides immediate value to museum staff daily workflows, enables efficient bulk data management",
      "prerequisite": "Stage 0 React infrastructure must be complete",
      "confidence_level": "high",
      "status": "in_progress",
      "implementation_status": {
        "languoid_batch_editor": "complete (production)",
        "collaborator_batch_editor": "complete (production - fully harmonized with Languoid patterns, conflict detection implemented, user guide complete)",
        "item_batch_editor": "not_started",
        "document_batch_editor": "not_started"
      },
      "critical_reference": "See collaborator_batch_editor_lessons.json for comprehensive implementation protocol and lessons learned. This file contains 33-item conformance checklist PLUS 12 additional universal patterns established during Phase 6 harmonization that MUST be followed for all future batch editor implementations."
    },
    
    "technical_architecture": {
      "library_choice_reactgrid": {
        "decision_id": "stage1_016",
        "content": "ReactGrid initially selected as spreadsheet component library",
        "added_date": "2025-10-17",
        "deprecated_date": "2025-11-02",
        "library": "ReactGrid",
        "license": "MIT",
        "github": "https://github.com/silevis/reactgrid",
        "rationale": "TypeScript-first, custom cell types, modern React hooks, no jQuery dependencies, appeared to fit complex requirements",
        "key_capabilities": [
          "Custom cell renderers for display vs data separation",
          "Built-in copy/paste with Excel-like behavior",
          "Custom cell editors for overlay integration",
          "Change tracking via cell state",
          "Full TypeScript support",
          "Material-UI compatible for overlay dialogs"
        ],
        "deprecation_reason": "Performance limitations - lacks row virtualization, fails with 1,000+ rows due to out-of-memory errors",
        "superseded_by": "stage1_045 (TanStack Table migration)",
        "confidence_level": "high",
        "status": "deprecated"
      },
      
      "library_choice": {
        "decision_id": "stage1_045",
        "content": "TanStack Table with virtualization selected as spreadsheet component library",
        "added_date": "2025-11-02",
        "conversation_reference": "TanStack migration for 10,000+ row performance requirement",
        "library": "TanStack Table v8",
        "virtualization_library": "@tanstack/react-virtual",
        "license": "MIT",
        "github": "https://github.com/TanStack/table",
        "rationale": "Headless table library with row virtualization enables 10,000+ row performance. ReactGrid's lack of virtualization caused out-of-memory errors at 1,000+ rows.",
        "migration_trigger": "Production requirement to handle 10,000 rows smoothly. ReactGrid fundamentally cannot scale due to rendering all rows to DOM.",
        "key_capabilities": [
          "Row virtualization - only renders visible rows (~20-30 at a time)",
          "Headless architecture - full control over rendering and styling",
          "60 FPS scrolling with 10,000+ rows",
          "Flexible cell rendering system",
          "TypeScript-first API",
          "No built-in UI constraints"
        ],
        "performance_characteristics": {
          "target_dataset": "10,000 rows, 10 columns",
          "scroll_fps": "60 FPS",
          "cell_edit_latency": "<100ms",
          "selection_toggle": "<50ms",
          "undo_redo": "<100ms",
          "memory_usage": "Constant (virtualized rendering)"
        },
        "confidence_level": "high",
        "status": "active"
      },
      
      "component_architecture": {
        "decision_id": "stage1_017",
        "content": "Reusable core with model-specific wrappers pattern",
        "added_date": "2025-10-17",
        "updated_date": "2025-11-02",
        "pattern": "Generic TanStackSpreadsheet component reused across all models with model-specific configuration wrappers",
        "reusable_core": [
          "TanStackSpreadsheet.tsx (virtualized grid with keyboard navigation, selection, copy/paste)",
          "MemoizedSpreadsheetCell.tsx (optimized cell rendering with custom equality function)",
          "CellEditor.tsx (modal editor for all cell types)",
          "TanStackSpreadsheetWrapper.tsx (toolbar + grid container)",
          "Cell type definitions (text, decimal, select, relationship, multiselect, stringarray, boolean, readonly)",
          "Change tracking logic",
          "Validation framework (client-side + backend)",
          "Redux state management (batchSpreadsheetSlice with undo/redo)"
        ],
        "model_specific_wrappers": [
          "LanguoidBatchEditor.tsx (COMPLETE - column config + languoid-specific validation + conflict detection)",
          "CollaboratorBatchEditor.tsx (COMPLETE - column config + collaborator-specific validation + M2M language fields + conflict detection + full UX harmonization with Languoid)",
          "ItemBatchEditor.tsx (PLANNED - column config + item-specific validation)",
          "DocumentBatchEditor.tsx (PLANNED - column config + document-specific validation)"
        ],
        "implementation_notes": "Collaborator batch editor implementation complete. All 33 conformance requirements met, plus 12 additional universal patterns established during final harmonization phase. User guide documentation complete. System ready for Item batch editor implementation using established patterns.",
        "component_hierarchy": "LanguoidBatchEditor ‚Üí AdaptiveSpreadsheetGrid ‚Üí TanStackSpreadsheetWrapper ‚Üí TanStackSpreadsheet ‚Üí MemoizedSpreadsheetCell ‚Üí CellEditor",
        "code_reuse_percentage": "~95% shared core, ~5% model-specific configuration",
        "confidence_level": "high",
        "status": "active"
      },
      
      "data_flow_architecture": {
        "decision_id": "stage1_018",
        "content": "Cell data structure separating display values from machine-readable data",
        "added_date": "2025-10-17",
        "updated_date": "2025-11-02",
        "cell_structure": {
          "text": "Human-friendly display value (e.g., 'English, Spanish, French')",
          "value": "Machine-readable data (e.g., [1, 5, 12] - array of IDs)",
          "type": "Cell type (text, decimal, select, relationship, multiselect, stringarray, boolean, readonly)",
          "isEdited": "Change tracking flag",
          "originalValue": "Value when loaded from DB",
          "validationState": "valid | invalid | none",
          "validationError": "Error message if invalid",
          "hasConflict": "Conflict detection flag (field-level optimistic locking)",
          "fieldName": "Model field name",
          "readOnly": "Optional flag for display-only fields (e.g., ID)"
        },
        "row_structure": {
          "id": "Database ID or 'draft-{uuid}' for new rows",
          "cells": "Record of field name to SpreadsheetCell",
          "isDraft": "True if new row not yet saved",
          "hasChanges": "True if any cell edited",
          "hasErrors": "True if any validation errors",
          "isSelected": "True if row checkbox selected (Phase 9 - bulk actions)",
          "version": "For optimistic locking conflict detection",
          "_updated": "Database timestamp for conflict detection"
        },
        "state_structure": {
          "rows": "Array of SpreadsheetRow",
          "loading": "Data fetch in progress",
          "saving": "Save operation in progress",
          "error": "Error message string | null",
          "successMessage": "Success message string | null",
          "validatingCells": "Array of cell IDs being validated",
          "undoStack": "Array of HistoryEntry (max 50, Phase 8)",
          "redoStack": "Array of HistoryEntry (Phase 8)",
          "maxHistorySize": "50 actions"
        },
        "confidence_level": "high",
        "status": "active"
      }
    },
    
    "smart_spreadsheet_interface": {
      "visual_design": {
        "decision_id": "stage1_002",
        "content": "Interface that looks and behaves exactly like a spreadsheet with Google Sheets-style UX",
        "added_date": "2025-01-04",
        "appearance": "Standard spreadsheet grid with rows and columns",
        "column_mapping": "Each column corresponds to a model field",
        "row_mapping": "Each row corresponds to a model instance (existing or draft)",
        "interaction_paradigm": "Copy/paste operations for batch editing across cells",
        "confidence_level": "high",
        "status": "planned"
      },
      
      "smart_cell_architecture": {
        "decision_id": "stage1_003",
        "content": "Cells display human-friendly text but contain machine-readable JSON data",
        "added_date": "2025-01-04",
        "display_states": {
          "inactive": "Human-friendly text display (e.g., list of language names)",
          "editing": "Machine-readable JSON displayed as editable text",
          "overlay": "Rich UI overlay for complex field editing"
        },
        "data_flow": "Human display ‚Üî JSON data ‚Üî overlay UI ‚Üî validation ‚Üî save",
        "validation_integration": "Per-cell validation via internal API endpoints with visual feedback",
        "confidence_level": "high",
        "status": "planned"
      },
      
      "overlay_editing_system": {
        "decision_id": "stage1_004",
        "content": "Rich overlay UI for editing complex fields like M2M and FK relationships",
        "added_date": "2025-01-04",
        "trigger": "User clicks on cell to open overlay for complex field types",
        "functionality": "Overlay populated with current valid JSON data from cell",
        "ui_components": "Field-appropriate editing interfaces (dropdowns, multi-select, etc.)",
        "data_persistence": "Overlay saves data back to cell as valid JSON",
        "user_experience": "Seamless transition between spreadsheet and rich editing",
        "confidence_level": "high",
        "status": "planned"
      }
    },
    
    "batch_editing_operations": {
      "copy_paste_functionality": {
        "decision_id": "stage1_005",
        "content": "Core batch editing through spreadsheet copy/paste operations with intelligent validation",
        "added_date": "2025-01-04",
        "same_column_paste": "Copy cell to multiple rows in same column for bulk assignment",
        "cross_column_paste": "Paste to different field type triggers validation error (red highlight)",
        "data_preservation": "Cells maintain valid machine-readable JSON for reliable copying",
        "validation_feedback": "Invalid pastes immediately highlighted red with error messages",
        "confidence_level": "high",
        "status": "planned"
      },
      
      "change_tracking": {
        "decision_id": "stage1_006",
        "content": "Visual tracking of all changes with multiple highlight states",
        "added_date": "2025-01-04",
        "highlight_states": {
          "yellow": "User has edited this cell",
          "red": "Validation error in this cell",
          "orange": "User edit that conflicts with updated DB data (concurrent editing)"
        },
        "change_persistence": "All changes tracked until save or discard operation",
        "save_requirements": "Cannot save with any red (invalid) cells",
        "confidence_level": "high",
        "status": "planned"
      }
    },
    
    "data_management": {
      "existing_object_handling": {
        "decision_id": "stage1_007",
        "content": "Smart detection and population of existing objects based on unique identifiers",
        "added_date": "2025-01-04",
        "identification": "Match existing objects by unique fields (catalog_number for Items)",
        "data_population": "Populate cells with existing DB data for matched objects",
        "change_detection": "Only show fields that differ from current DB state",
        "update_behavior": "Changes only applied to modified fields during save operation",
        "confidence_level": "high",
        "status": "planned"
      },
      
      "draft_object_handling": {
        "decision_id": "stage1_008",
        "content": "Frontend state management for objects not yet in database",
        "added_date": "2025-01-04",
        "storage_approach": "Draft objects exist only in React state until save operation",
        "data_structure": "Same structure as DB objects but flagged as drafts",
        "validation": "Full validation applied to draft objects before save",
        "persistence": "Lost on page refresh/discard - no backend staging system needed",
        "save_behavior": "Created in DB during transaction-based save operation",
        "confidence_level": "high",
        "status": "planned"
      }
    },
    
    "spreadsheet_upload_integration": {
      "upload_processing": {
        "decision_id": "stage1_009",
        "content": "Spreadsheet upload pipes directly to smart spreadsheet interface instead of automatic ingestion",
        "added_date": "2025-01-04",
        "process_flow": "Upload ‚Üí Parse ‚Üí Populate spreadsheet UI ‚Üí User review/edit ‚Üí Save",
        "object_matching": "Attempt to match uploaded rows to existing objects by unique identifiers",
        "field_parsing": "Intelligent parsing of text fields (comma-separated lists for M2M)",
        "change_highlighting": "Only fields different from DB are highlighted and shown as changed",
        "user_control": "User can review, edit, and selectively save changes before DB modification",
        "confidence_level": "high",
        "status": "planned"
      },
      
      "field_interpretation": {
        "decision_id": "stage1_010",
        "content": "Smart parsing of uploaded spreadsheet data for complex field types",
        "added_date": "2025-01-04",
        "text_parsing": "Convert comma-separated lists to M2M relationships",
        "fk_resolution": "Attempt to resolve foreign key references by name/identifier",
        "validation_feedback": "Unparseable data highlighted for user correction",
        "fallback_behavior": "Unresolvable data preserved as text for manual correction",
        "confidence_level": "medium",
        "status": "planned"
      }
    },
    
    "save_operations": {
      "transaction_based_saves": {
        "decision_id": "stage1_011",
        "content": "All-or-nothing save operations with selective row saving capability",
        "added_date": "2025-01-04",
        "transaction_scope": "All selected rows must save successfully or entire operation rolls back",
        "row_selection": "User can select specific rows to save, leaving others unchanged",
        "validation_blocking": "Save operation blocked if any selected rows have validation errors",
        "error_handling": "Clear feedback on which rows/cells prevent save operation",
        "success_feedback": "Clear indication of which rows were successfully saved",
        "confidence_level": "high",
        "status": "planned"
      }
    },
    
    "concurrent_editing_handling": {
      "optimistic_locking": {
        "decision_id": "stage1_012",
        "content": "Basic concurrent editing protection with conflict detection and user resolution",
        "added_date": "2025-01-04",
        "change_detection": "Check if objects changed since UI was populated",
        "conflict_behavior": "Fail transaction and repopulate row with current DB data",
        "user_edit_preservation": "Maintain user's edited values (yellow highlighting)",
        "conflict_highlighting": "Orange highlighting for user edits that conflict with updated data",
        "resolution_process": "User manually reviews orange cells and decides on final values",
        "confidence_level": "medium",
        "status": "planned"
      }
    },
    
    "implementation_phases": {
      "phase_sequencing": {
        "decision_id": "stage1_019",
        "content": "Seven-phase implementation approach building from foundation to complete feature",
        "added_date": "2025-10-17",
        "updated_date": "2025-10-17",
        "phase_order_revision": "Phase 3 (Save Operations) moved before Phase 4-5 (Custom Cell Types and Overlay Editors) to enable proper testing earlier. Save is simpler to implement and required for testing subsequent phases.",
        "phases": {
          "phase_1": {
            "title": "Foundation & Basic Grid (Languoids)",
            "timeline": "Week 1",
            "deliverables": [
              "Install ReactGrid library",
              "Create SpreadsheetGrid reusable component",
              "Implement basic text cell type",
              "Create Redux slices (batchSpreadsheetSlice)",
              "Load languoids into grid with manual row addition"
            ],
            "excludes": ["Upload functionality deferred to Phase 6"],
            "status": "complete"
          },
          "phase_2": {
            "title": "Change Tracking & Validation",
            "timeline": "Week 1-2",
            "deliverables": [
              "Implement change tracking with yellow highlighting",
              "Add validation framework",
              "Create backend validate-field endpoint",
              "Show validation errors with red highlighting",
              "Implement debounced cell-level validation"
            ],
            "status": "complete"
          },
          "phase_3": {
            "title": "Save Operations",
            "timeline": "Week 2",
            "deliverables": [
              "Backend save-batch endpoint with transactions",
              "Frontend save handler collecting edited rows",
              "Success/error feedback UI (snackbar/alerts)",
              "Reset dirty flags after successful save",
              "Basic save workflow (no conflict detection yet)"
            ],
            "deferred_to_phase_6": [
              "Conflict detection via version numbers",
              "Orange highlighting for conflicts",
              "Selective row saving (save selected rows only)"
            ],
            "rationale": "Simpler implementation than custom cell types, enables proper testing of all subsequent features",
            "status": "ready"
          },
          "phase_4": {
            "title": "Custom Cell Types",
            "timeline": "Week 2-3",
            "deliverables": [
              "SelectCell for choice fields",
              "RelationshipCell for FK fields",
              "MultiSelectCell for M2M fields",
              "BooleanCell for three-state boolean",
              "DateCell for date fields",
              "StringArrayCell for JSONField string arrays",
              "DecimalCell for decimal number fields (longitude, latitude)"
            ],
            "testing_note": "Now properly testable with Phase 3 save operations in place",
            "status": "complete",
            "selectcell_completion": {
              "date": "2025-10-19",
              "implementation_learnings": "Critical patterns discovered during SelectCell implementation that apply to all custom cell types",
              "status": "complete"
            },
            "relationshipcell_completion": {
              "date": "2025-10-19",
              "implementation_learnings": "FK field editing with autocomplete search, API integration patterns, keyboard event isolation, performance optimization",
              "status": "complete"
            },
            "multiselectcell_completion": {
              "date": "2025-10-19",
              "implementation_learnings": "Multi-action editing sessions require static class member storage (not React state) to prevent focus loss. Pattern documented in stage1_033 for future multi-action cells",
              "status": "complete"
            },
            "datecell_completion": {
              "date": "2025-10-19",
              "implementation_learnings": "Date field editing integrates Stage 0 flexible date handling (DateInterpretationFeedback, DateFormatHelp) with Stage 1 ReactGrid architecture. Pattern documented in stage1_034",
              "status": "complete",
              "note": "Languoid model has no date fields, but DateCell is ready for future models (Item, Collection, Collaborator, Document)"
            },
            "booleancell_completion": {
              "date": "2025-10-19",
              "implementation_learnings": "Three-state boolean editing (Yes/No/Not specified) matches Stage 0 EditableBooleanField patterns. Simple SelectCell variant with fixed choices. Pattern documented in stage1_035",
              "status": "complete"
            },
            "stringarraycell_status": {
              "date": "2025-10-19",
              "status": "complete",
              "implementation_learnings": "String array editing for JSONField with tag/chip input UI. Follows MultiSelectCell static state patterns but for plain text instead of relationships. Pattern documented in stage1_036"
            },
            "decimalcell_completion": {
              "date": "2025-10-20",
              "status": "complete",
              "implementation_learnings": "Decimal number field editing for coordinates and measurements. Simple text-based editor with numeric validation. Applied to longitude/latitude fields in Languoid batch editor. Pattern documented in stage1_037"
            }
          },
          "phase_5": {
            "title": "Overlay Editors",
            "timeline": "Week 3-4",
            "deliverables": [
              "RelationshipEditor Material-UI dialog",
              "MultiSelectEditor Material-UI dialog",
              "DateEditor Material-UI dialog",
              "Wire overlay editors to cell types",
              "Implement search/filter in overlays"
            ],
            "testing_note": "Can save after using overlay editors thanks to Phase 3",
            "status": "deferred",
            "deferral_decision": {
              "date": "2025-10-20",
              "rationale": "Phase 4 inline editors (MultiSelectCell, RelationshipCell, DateCell, etc.) are fully functional and sufficient for current needs. Overlay dialogs add complexity without clear UX benefit at this stage. Decision can be revisited after user testing reveals whether overlays are needed.",
              "deferred_until": "Post-Phase 8 or based on user feedback",
              "note": "If overlays are needed later, likely candidates are MultiSelectCell (for very large M2M lists) and RelationshipCell (for advanced filtering)"
            }
          },
          "phase_6": {
            "title": "Conflict Detection & Advanced Save",
            "timeline": "Week 4-5",
            "deliverables": [
              "Optimistic locking with version numbers",
              "Orange highlighting for conflicts",
              "Selective row saving (save selected rows only)",
              "Conflict resolution UI",
              "Enhanced save operations from Phase 3"
            ],
            "status": "deferred",
            "deferral_decision": {
              "date": "2025-10-20",
              "rationale": "Basic save operations from Phase 3 are sufficient for single-user scenarios and initial deployment. Conflict detection adds complexity that can be added later when multi-user concurrent editing becomes a real use case. Current priority is to complete core functionality (upload, other models) for user testing.",
              "deferred_until": "Post-Phase 8 or when concurrent editing issues are reported",
              "note": "Version field migration can be added to models now for future-proofing, but conflict detection logic can wait"
            }
          },
          "phase_7": {
            "title": "Upload Integration",
            "timeline": "Week 5-6",
            "deliverables": [
              "Spreadsheet parser (xlsx, csv)",
              "Upload dialog component",
              "Parse ‚Üí populate grid workflow",
              "Smart matching of existing objects by unique IDs",
              "Highlight changed fields from DB"
            ],
            "status": "pending"
          },
          "phase_8": {
            "title": "Collaborators & Items",
            "timeline": "Week 6-8",
            "deliverables": [
              "CollaboratorBatchEditor wrapper with config",
              "ItemBatchEditor wrapper with config",
              "Model-specific validation rules",
              "Testing across all three models"
            ],
            "status": "pending"
          }
        },
        "confidence_level": "high",
        "status": "in_progress"
      },
      
      "model_implementation_order": {
        "decision_id": "stage1_013",
        "content": "Languages/Languoids ‚Üí Collaborators ‚Üí Items implementation sequence",
        "added_date": "2025-01-04",
        "updated_date": "2025-10-17",
        "phase_1_model": "Languages/Languoids (simpler model for testing core functionality)",
        "phase_8_models": "Collaborators then Items (increasing complexity)",
        "field_type_approach": "Implement all field types together rather than text-first incremental approach",
        "rationale": "Complex fields drive most of the UI complexity, so partial implementation not useful for testing",
        "confidence_level": "high",
        "status": "in_progress"
      }
    },
    
    "api_requirements": {
      "validation_endpoints": {
        "decision_id": "stage1_014",
        "content": "Internal API endpoints for per-cell validation and save operations",
        "added_date": "2025-01-04",
        "per_cell_validation": "Endpoint to validate individual field values in real-time",
        "bulk_validation": "Endpoint to validate entire row or multiple rows before save",
        "save_operations": "Transaction-based endpoints for saving selected rows",
        "change_detection": "Endpoints to check if objects have been modified since last fetch",
        "confidence_level": "high",
        "status": "planned"
      }
    },
    
    "operational_decisions": {
      "data_loading_modes": {
        "decision_id": "stage1_020",
        "content": "Three distinct modes for populating the spreadsheet grid",
        "added_date": "2025-10-17",
        "mode_a_selected_rows": {
          "trigger": "User selects rows in list view then clicks 'Batch Edit' button",
          "behavior": "Spreadsheet opens pre-populated with selected objects",
          "performance_warning": "Warn user if no rows selected that ALL objects will load (may impact performance)"
        },
        "mode_b_upload": {
          "trigger": "User uploads spreadsheet file",
          "behavior": "Grid populated with uploaded rows, matching existing objects by unique IDs where possible",
          "implementation_phase": "Phase 6"
        },
        "mode_c_quick_filters": {
          "trigger": "User applies model-specific quick filters",
          "behavior": "Load subset of objects based on filter criteria (e.g., 'Recent 100', 'Modified this week')",
          "model_specific": "Each model can define its own quick filter presets"
        },
        "confidence_level": "high",
        "status": "decided"
      },
      
      "permissions_and_access": {
        "decision_id": "stage1_021",
        "content": "Batch editing uses same permissions as individual CRUD operations",
        "added_date": "2025-10-17",
        "permission_class": "IsAuthenticatedWithEditAccess (Staff OR Archivist/Museum Staff groups)",
        "rationale": "Consistency with Stage 0 patterns, users already have edit access for individual operations",
        "future_consideration": "Can tighten to Archivist-only if needed based on usage",
        "confidence_level": "high",
        "status": "decided"
      },
      
      "responsive_design_strategy": {
        "decision_id": "stage1_022",
        "content": "Fully responsive design with relaxed constraints for mobile",
        "added_date": "2025-10-17",
        "desktop": {
          "support_level": "Full",
          "target": "Primary use case",
          "compliance": "Full ADA compliance, all features optimized"
        },
        "tablet": {
          "support_level": "Full",
          "target": "Secondary use case",
          "compliance": "Full ADA compliance, touch-optimized overlays"
        },
        "mobile_phone": {
          "support_level": "Functional but constrained",
          "target": "Limited/emergency use only",
          "compliance": "Relaxed ADA requirements acceptable",
          "acceptable_limitations": "UI elements may be smaller than ideal, spreadsheet cells may require zooming, some features may be difficult to use",
          "rationale": "Spreadsheet UX inherently desktop-oriented, mobile is not primary use case"
        },
        "confidence_level": "high",
        "status": "decided"
      },
      
      "existing_import_migration": {
        "decision_id": "stage1_023",
        "content": "Gradual migration strategy keeping Django import parallel during development",
        "added_date": "2025-10-17",
        "approach": "Model-by-model replacement",
        "migration_sequence": [
          "Phase 1-6: Build Languoid batch editor, keep existing Item/Collaborator import active",
          "Phase 7: Add Collaborator batch editor, deprecate Collaborator import",
          "Phase 7: Add Item batch editor, deprecate Item import",
          "Post-Stage 1: Remove Django ImportView entirely"
        ],
        "rationale": "Minimizes disruption to users, allows gradual transition, provides fallback during development",
        "user_communication": "Notify users of new batch editing features as they become available",
        "confidence_level": "high",
        "status": "decided"
      }
    },
    
    "custom_cell_implementation_patterns": {
      "overview": {
        "decision_id": "stage1_024",
        "content": "Critical patterns and lessons learned from SelectCell implementation that apply to all custom cell types",
        "added_date": "2025-10-19",
        "source": "SelectCell implementation (Phase 4.1)",
        "importance": "HIGH - These patterns are mandatory for all future custom cell implementations",
        "confidence_level": "high",
        "status": "documented"
      },
      
      "reactgrid_integration_architecture": {
        "decision_id": "stage1_025",
        "content": "How custom cells integrate with ReactGrid's template system",
        "added_date": "2025-10-19",
        "required_components": {
          "cell_interface": "TypeScript interface extending Cell from ReactGrid, must include validationState and isEdited for styling",
          "cell_template_class": "Class implementing CellTemplate<YourCell> with required methods",
          "cell_view_component": "React component for rendering cell content (both display and edit modes)"
        },
        "template_methods": {
          "getCompatibleCell": {
            "purpose": "Convert uncertain cell data to compatible cell format",
            "critical_requirement": "MUST preserve validationState and isEdited properties - ReactGrid strips them by default",
            "implementation": "Explicitly extract and include (uncertainCell as any).validationState and isEdited in returned cell object",
            "failure_mode": "If not preserved, cells won't show color highlighting (yellow/red/blue)"
          },
          "isFocusable": {
            "purpose": "Tell ReactGrid this cell can receive focus and enter edit mode",
            "implementation": "Return true for all interactive cells",
            "failure_mode": "If missing or returns false, cell won't respond to Enter/double-click"
          },
          "handleKeyDown": {
            "purpose": "Handle keyboard events before ReactGrid processes them",
            "critical_complexity": "Controls edit mode state via return value { cell, enableEditMode: boolean }",
            "state_tracking_pattern": "Use static Set to track which cells are currently being edited",
            "enter_key_behavior": "If cell NOT in editing set: add to set and return enableEditMode: true. If cell IS in editing set: remove from set and return enableEditMode: false",
            "escape_key_behavior": "Always remove from set and return enableEditMode: false",
            "failure_modes": [
              "Without state tracking: Enter key will re-enable edit mode after commit, causing stuck-in-edit-mode",
              "ReactGrid's handleKeyDown is called independently of React event handlers",
              "React's onKeyDown with stopPropagation doesn't prevent ReactGrid's template handleKeyDown from firing"
            ]
          },
          "update": {
            "purpose": "Merge updated cell properties when cell changes",
            "implementation": "Call getCompatibleCell with merged properties",
            "note": "Relies on getCompatibleCell preserving all custom properties"
          },
          "render": {
            "purpose": "Return React component to render the cell",
            "implementation": "Return <YourCellView cell={cell} isInEditMode={isInEditMode} onCellChanged={onCellChanged} />",
            "note": "isInEditMode is controlled by ReactGrid based on handleKeyDown return values"
          }
        },
        "confidence_level": "high",
        "status": "documented"
      },
      
      "spreadsheet_ux_patterns": {
        "decision_id": "stage1_026",
        "content": "Custom cells must mimic standard spreadsheet behavior for user familiarity",
        "added_date": "2025-10-19",
        "display_mode_behavior": {
          "appearance": "Plain text display with background color based on validation state",
          "cursor": "Default cursor",
          "keyboard_navigation": "Arrow keys move between cells (NOT intercepted by cell)",
          "enter_key": "Enters edit mode for this cell",
          "double_click": "Enters edit mode for this cell",
          "implementation_note": "Do NOT use preventDefault/stopPropagation on arrow keys in display mode"
        },
        "edit_mode_behavior": {
          "appearance": "Custom editor UI (dropdown, date picker, etc.) with focus maintained on cell",
          "cursor": "Appropriate for editor type",
          "keyboard_navigation": {
            "arrow_keys": "Navigate WITHIN the custom editor (e.g., dropdown options), NOT between cells",
            "enter_key": "Commit selection and exit edit mode",
            "escape_key": "Cancel edit and exit edit mode without committing",
            "implementation_requirement": "MUST call preventDefault() and stopPropagation() on arrow keys to prevent ReactGrid navigation"
          },
          "mouse_behavior": {
            "click_option": "Select and commit (for dropdowns)",
            "click_away": "Exit edit mode (handled by blur)"
          }
        },
        "edit_mode_entry": {
          "triggers": ["Enter key", "Double-click (keyCode: 1 in ReactGrid's handleKeyDown)"],
          "implementation": "Template's handleKeyDown returns enableEditMode: true for keyCode 13 or 1",
          "state_management": "Add cell to editing Set when entering edit mode"
        },
        "edit_mode_exit": {
          "commit_triggers": ["Enter key (after selecting value)", "Click option in dropdown", "Blur input element"],
          "cancel_triggers": ["Escape key"],
          "implementation_for_commit": {
            "step_1": "Call onCellChanged(updatedCell, true) to update Redux state",
            "step_2": "Blur the input element (inputRef.current.blur())",
            "step_3": "Let Enter event propagate to ReactGrid (do NOT stopPropagation)",
            "step_4": "ReactGrid's template handleKeyDown sees Enter, detects cell in editing Set, removes it, returns enableEditMode: false",
            "critical_timing": "Blur must happen AFTER onCellChanged but can use setTimeout(..., 0) to ensure proper event ordering"
          },
          "implementation_for_cancel": {
            "step_1": "Manually remove cell from editing Set in React's onKeyDown handler",
            "step_2": "Close dropdown/editor UI",
            "step_3": "Blur input element",
            "step_4": "Call onCellChanged(cell, false)",
            "step_5": "Let Escape propagate naturally (ReactGrid may not call template handleKeyDown for Escape)",
            "critical_note": "React's event handler fires BEFORE ReactGrid's template handleKeyDown, so manual Set cleanup is required"
          }
        },
        "confidence_level": "high",
        "status": "documented"
      },
      
      "focus_management_patterns": {
        "decision_id": "stage1_027",
        "content": "Maintaining focus within cell during edit mode to prevent ReactGrid from exiting edit mode prematurely",
        "added_date": "2025-10-19",
        "the_core_problem": "ReactGrid monitors focus to determine edit mode state. If focus leaves the cell, ReactGrid exits edit mode.",
        "the_solution": "Use a transparent input element to maintain focus within the cell while rendering custom UI over/around it",
        "input_element_pattern": {
          "purpose": "Act as focus anchor, not for actual text input",
          "attributes": {
            "autoFocus": "true - ensures input gets focus when edit mode starts",
            "ref": "inputRef - needed for programmatic blur() on commit/cancel",
            "value": "cell.text or cell.value - display current value but ignore changes",
            "onChange": "Empty handler - we don't use this input for data entry",
            "style": {
              "background": "transparent - custom UI renders on top",
              "caretColor": "transparent - hide text cursor",
              "border": "none",
              "outline": "none",
              "cursor": "default or pointer depending on UI"
            }
          }
        },
        "custom_ui_positioning": {
          "dropdown_pattern": "Render dropdown as sibling to input, absolutely positioned at top: '100%' to appear below cell",
          "overlay_pattern": "Use React Portal to render outside ReactGrid DOM if needed",
          "z_index": "Use high z-index (10000+) to ensure dropdown appears above grid"
        },
        "preventing_focus_loss": {
          "problem": "Clicking dropdown options causes input to lose focus, ReactGrid exits edit mode",
          "solution": "Use CAPTURE PHASE event handlers to intercept events before ReactGrid sees them",
          "implementation": {
            "dropdown_container": "Add onPointerDownCapture={(e) => { e.preventDefault(); e.stopPropagation(); }}",
            "dropdown_options": "Add onPointerDownCapture and onClickCapture with preventDefault and stopPropagation",
            "why_capture_phase": "Capture phase fires BEFORE ReactGrid's event handlers, allowing us to prevent default behavior",
            "why_pointer_not_mouse": "PointerDown captures both mouse and touch events, more reliable than MouseDown"
          },
          "failed_approaches": [
            "Using stopPropagation in bubble phase - ReactGrid intercepts events earlier",
            "Using ClickAwayListener - conflicts with ReactGrid's focus management",
            "Using React Portal for dropdown - focus still tracked by ReactGrid, causes issues",
            "Manual document.addEventListener for click-away - ReactGrid exits edit mode before handler fires"
          ]
        },
        "confidence_level": "high",
        "status": "documented"
      },
      
      "validation_and_styling_integration": {
        "decision_id": "stage1_028",
        "content": "How custom cells display validation states and edit status with colored backgrounds",
        "added_date": "2025-10-19",
        "color_scheme": {
          "yellow_background": "#fff9c4 - cell has been edited (isEdited: true)",
          "red_background": "#ffebee - validation error (validationState: 'invalid')",
          "blue_background": "#e3f2fd - validation in progress (validationState: 'validating')",
          "transparent": "No changes, valid (isEdited: false, validationState: 'valid')"
        },
        "implementation_requirements": {
          "cell_interface": "Must include optional validationState and isEdited properties",
          "getCompatibleCell_method": "MUST preserve these properties from uncertainCell: validationState: (uncertainCell as any).validationState, isEdited: (uncertainCell as any).isEdited",
          "spreadsheet_grid_mapping": "When creating ReactGrid cells from SpreadsheetCell data, explicitly pass validationState and isEdited",
          "cell_view_component": "Create getCellBackgroundColor() helper function that checks validationState and isEdited, return appropriate color string"
        },
        "application_points": {
          "display_mode": "Apply backgroundColor to outermost container div",
          "edit_mode": "Apply backgroundColor to outermost container div (input has transparent background)"
        },
        "common_failure_mode": {
          "symptom": "Colors don't show even though Redux state has correct validationState/isEdited values",
          "cause": "getCompatibleCell() method strips out custom properties when creating cell object",
          "diagnosis": "Add console.log in cell render to check if validationState/isEdited are undefined",
          "fix": "Update getCompatibleCell to explicitly preserve these properties using (uncertainCell as any).propertyName"
        },
        "confidence_level": "high",
        "status": "documented"
      },
      
      "state_management_patterns": {
        "decision_id": "stage1_029",
        "content": "How validation and edit states flow between Redux, ReactGrid, and cell components",
        "added_date": "2025-10-19",
        "data_flow": {
          "user_edits_cell": [
            "1. Cell's onChange/onSelect handler calls onCellChanged(updatedCell, commit)",
            "2. SpreadsheetGrid's handleChanges processes the change",
            "3. Model wrapper's handleCellChange is called",
            "4. Dispatch updateCell() Redux action with new value",
            "5. Redux reducer updates cell.value and automatically sets cell.isEdited by comparing to originalValue",
            "6. handleCellChange calls validateField() if value differs from originalValue",
            "7. Validation hook dispatches updateCell() with validationState: 'validating'",
            "8. After debounce, backend validation returns, dispatch updateCell() with 'valid' or 'invalid'",
            "9. Redux state updates trigger React re-render",
            "10. SpreadsheetGrid maps updated SpreadsheetCell to ReactGrid cell format",
            "11. ReactGrid re-renders cell with new validationState/isEdited",
            "12. Cell's getCellBackgroundColor() returns appropriate color",
            "13. User sees yellow (edited) or red (invalid) or blue (validating) background"
          ]
        },
        "critical_redux_patterns": {
          "isEdited_calculation": "Redux reducer MUST compare cell.value !== cell.originalValue, not rely on passed flag",
          "originalValue_immutability": "originalValue is set on load and NEVER mutated by edits, only by successful save",
          "short_circuit_optimization": "If newValue === originalValue, immediately set validationState: 'valid' and skip backend call"
        },
        "validation_flow_optimization": {
          "debouncing": "Use 500ms debounce to avoid excessive API calls during typing",
          "validating_state": "Set immediately before debounce starts to give instant feedback",
          "cleanup_on_unmount": "Clear all debounce timers when component unmounts"
        },
        "confidence_level": "high",
        "status": "documented"
      },
      
      "debugging_strategies": {
        "decision_id": "stage1_030",
        "content": "Systematic approach to debugging custom cell issues based on SelectCell experience",
        "added_date": "2025-10-19",
        "common_issue_patterns": {
          "colors_not_showing": {
            "check_1": "Add console.log in getCellBackgroundColor() to see validationState/isEdited values",
            "check_2": "If undefined: problem is in getCompatibleCell() not preserving properties",
            "check_3": "If defined: problem is in backgroundColor style application or CSS override",
            "fix": "Update getCompatibleCell() to preserve properties, ensure backgroundColor is applied to correct element"
          },
          "stuck_in_edit_mode": {
            "symptom": "After pressing Enter/Escape, dropdown closes but cell still has focus, arrow keys don't navigate",
            "check_1": "Add console.log in template's handleKeyDown to see if it's being called",
            "check_2": "Check if cell is in editing Set when it shouldn't be",
            "check_3": "Check if isInEditMode prop is still true after commit",
            "root_cause": "Template's handleKeyDown returning enableEditMode: true when it should return false",
            "fix": "Implement state tracking Set, ensure Enter on already-editing cell returns enableEditMode: false"
          },
          "edit_mode_not_entering": {
            "symptom": "Pressing Enter or double-clicking doesn't open editor",
            "check_1": "Verify isFocusable() returns true",
            "check_2": "Add console.log in handleKeyDown to see if it receives Enter (keyCode 13) or pointer event (keyCode 1)",
            "check_3": "Check if cell is already in editing Set (shouldn't be for a cell not in edit mode)",
            "common_cause": "Previous edit didn't properly clean up editing Set",
            "fix": "Ensure Escape handler manually removes from Set since ReactGrid may not call handleKeyDown for Escape"
          },
          "dropdown_closes_on_click": {
            "symptom": "Clicking dropdown option immediately closes dropdown without selecting",
            "root_cause": "ReactGrid detects focus loss when click event fires",
            "check_1": "Verify onPointerDownCapture handlers are present on dropdown container and options",
            "check_2": "Verify handlers call e.preventDefault() and e.stopPropagation()",
            "check_3": "Check browser console for event handler errors",
            "fix": "Add capture phase handlers with preventDefault/stopPropagation to all interactive dropdown elements"
          },
          "values_revert_after_edit": {
            "symptom": "Edit a cell, press Enter, value changes back to original",
            "check_1": "Add console.log in Redux updateCell reducer to see if action is dispatched",
            "check_2": "Check if row is found (rowId type mismatch: string vs number)",
            "check_3": "Check if cell properties are actually being updated in Redux state",
            "common_cause": "Row lookup fails due to toString() comparison not being used",
            "fix": "Compare r.id.toString() === rowId.toString() in Redux reducer"
          }
        },
        "logging_strategy": {
          "template_methods": "Add console.log at start of handleKeyDown, getCompatibleCell to trace ReactGrid calls",
          "cell_view_component": "Log in handleKeyDown, handleSelect, getCellBackgroundColor to trace user interactions",
          "redux_actions": "Log in reducer before and after state updates to verify state changes",
          "event_flow": "Use distinctive emojis (üéØ, üìä, ‚å®Ô∏è, üé®) to make logs easy to scan"
        },
        "confidence_level": "high",
        "status": "documented"
      },
      
      "architectural_lessons": {
        "decision_id": "stage1_031",
        "content": "High-level insights that will guide future cell type implementations",
        "added_date": "2025-10-19",
        "key_insights": [
          "ReactGrid's architecture is event-driven and focus-based, not state-based - work with its patterns, not against them",
          "Custom cells must maintain ReactGrid's illusion of being a simple spreadsheet while hiding complex UI underneath",
          "The template system is stateless - any state tracking must be done via static class members or external stores",
          "React's synthetic events and ReactGrid's event handling are independent systems that can conflict - use capture phase to mediate",
          "Validation and styling must flow through ReactGrid's cell update cycle - can't directly manipulate DOM or apply classes",
          "Testing requires the full stack (Redux + ReactGrid + custom cell) - isolated testing of cell components won't catch integration issues"
        ],
        "implementation_priorities": [
          "1. Get edit mode enter/exit working correctly FIRST - this is the foundation",
          "2. Add focus management and click handling - required for custom UI to function",
          "3. Integrate with Redux validation state - enables visual feedback",
          "4. Add custom UI (dropdowns, pickers, etc.) - actual functionality",
          "5. Polish and debug edge cases - refinement"
        ],
        "time_investment_lessons": [
          "Expect 60-70% of implementation time on edit mode state management and event handling",
          "Expect 20-30% on focus management and preventing premature edit mode exit",
          "Expect 10-20% on actual custom UI and validation integration",
          "The complexity is in the integration, not in the custom UI itself"
        ],
        "reusability_assessment": "Once SelectCell pattern is established, future cell types (RelationshipCell, MultiSelectCell, DateCell) can reuse 80%+ of the focus management, event handling, and validation integration code",
        "confidence_level": "high",
        "status": "documented"
      },
      
      "relationship_cell_patterns": {
        "decision_id": "stage1_032",
        "content": "Patterns specific to RelationshipCell (FK fields) that extend SelectCell foundation",
        "added_date": "2025-10-19",
        "source": "RelationshipCell implementation (Phase 4.2)",
        "builds_on": "SelectCell patterns (stage1_024 through stage1_031)",
        "api_integration_architecture": {
          "endpoint_configuration": "Column config includes relationshipEndpoint property (e.g., '/internal/v1/languoids/')",
          "dynamic_data_loading": "Unlike SelectCell with static choices, RelationshipCell fetches options from API on demand",
          "search_and_filter": "Append 'search' query param for filtering, 'page_size' param for limiting results",
          "response_format_expectations": "API must return { results: [ { id, name, ...otherFields }, ... ] } paginated format",
          "label_construction": "Map response to { value: id, label: displayString } format, support flexible display field names (name || title || display_name)",
          "caching_strategy": "Options loaded fresh each time dropdown opens - future optimization: cache with TTL"
        },
        "autocomplete_search_ui": {
          "search_input_placement": "TextField at top of dropdown for filtering options as user types",
          "debounced_api_calls": "300ms debounce on search query changes to limit API request frequency",
          "loading_indicator": "CircularProgress shown in search field endAdornment while fetching",
          "keyboard_event_isolation": "Critical: search input must NOT allow typing keys to reach ReactGrid",
          "isolation_implementation": {
            "selective_stopPropagation": "onKeyDownCapture handler checks if key is navigation key (Escape, Enter, arrows, Tab)",
            "navigation_keys": "Allow Escape, Enter, arrows, Tab to propagate to parent handlers for dropdown navigation",
            "typing_keys": "Stop propagation for backspace, letters, numbers, etc. so they work in search input",
            "why_capture_phase": "Must intercept in capture phase before ReactGrid's handlers see the events"
          }
        },
        "display_format_patterns": {
          "human_readable_display": "Display format often differs from stored value (e.g., 'Akkadian (akka1240)' not just ID)",
          "backend_support_required": "Serializer must include display-friendly read-only fields (e.g., parent_name, parent_glottocode)",
          "initial_load_display": "languoidToRow() constructs display text from parent_name + parent_glottocode when available",
          "post_selection_display": "Options array includes pre-formatted label, stored in cell.text after selection",
          "machine_value_storage": "cell.value always contains numeric ID, cell.text contains human-readable display"
        },
        "validation_integration_specifics": {
          "invalid_paste_detection": "When text pasted into relationship cell, value is null but text is not empty",
          "validation_short_circuit": "Check for null value + non-empty text BEFORE originalValue comparison",
          "error_message": "'Invalid relationship value. Please select from dropdown.'",
          "validation_order_criticality": "Must check relationship-specific invalid state before short-circuit comparison (null === null would incorrectly validate)"
        },
        "delete_clear_behavior": {
          "delete_key_handling": "Template's handleKeyDown handles DELETE (46) and BACKSPACE (8) keyCodes",
          "clear_operation": "Set value to null, text to empty string, preserve validationState and isEdited",
          "immediate_next_keypress": "Must remove cell from editingCells Set to allow immediate next Delete press without requiring cell navigation first"
        },
        "copy_paste_intelligence": {
          "valid_cell_copy": "Copying cell with valid relationship ID and pasting to another row works - value + text preserved",
          "invalid_text_paste": "Pasting arbitrary text (e.g., from non-relationship column) triggers validation error immediately",
          "spreadsheet_grid_detection": "handleChanges checks if text change occurred on relationship column, passes null value for validation"
        },
        "performance_considerations": {
          "console_log_impact": "Debug logging in hot paths (handleKeyDown, API calls, Redux updates) added 50-200ms per interaction",
          "removal_priority": "Remove ALL console.log statements before production, keep only console.error for actual errors",
          "react_memo_optimization": {
            "component_memoization": "RelationshipCellView wrapped in React.memo with custom comparison function (consistent with SelectCell and MultiSelectCell)",
            "comparison_logic": "Only re-renders if isInEditMode, cell.value, cell.text, validationState, isEdited, or relationshipEndpoint actually change",
            "why_custom_comparison": "Cell object is new reference on every grid update, but values might not change - custom comparison prevents unnecessary re-renders",
            "benefit": "When user types in different cell, RelationshipCells don't re-render unnecessarily"
          },
          "useMemo_for_cellKey": {
            "implementation": "cellKey calculated with useMemo([cell.value, cell.text, cell.relationshipEndpoint])",
            "why_needed": "cellKey used in Escape handler and static Set operations - memoization prevents recalculation on every render",
            "impact": "Small but measurable - string concatenation on every render adds up with many cells"
          },
          "useMemo_for_gridRows": "Memoize expensive gridRows calculation with [rows, columns] dependencies",
          "when_to_optimize": "Log removal + React.memo sufficient for 100-300 rows, additional optimization (useCallback, virtualization) needed for 500+"
        },
        "edge_cases_handled": {
          "empty_search_results": "Display empty state or 'No options found' when search returns no results",
          "api_error_handling": "Catch fetch errors, log to console.error, set options to empty array, show error in UI if needed",
          "long_option_labels": "Overflow handling in dropdown MenuItems with proper text wrapping or truncation",
          "concurrent_searches": "Debouncing prevents race conditions from rapid typing, last search wins"
        },
        "confidence_level": "high",
        "status": "documented"
      },
      
      "multiselect_cell_patterns": {
        "decision_id": "stage1_033",
        "content": "Patterns specific to MultiSelectCell (M2M fields) with multi-action editing sessions",
        "added_date": "2025-10-19",
        "source": "MultiSelectCell implementation (Phase 4.3)",
        "builds_on": "RelationshipCell patterns (stage1_032) and SelectCell foundation (stage1_024-031)",
        "critical_architectural_difference": "Unlike SelectCell/RelationshipCell which commit immediately after one selection, MultiSelectCell requires multiple user actions (add chip, remove chip, add another) before final commit",
        
        "static_state_management_pattern": {
          "problem": "React useState for selections causes re-renders that break ReactGrid focus during multi-action sessions",
          "why_react_state_fails": "Each setSelectedOptions() triggers React re-render, causing inputRef to be temporarily unmounted/remounted, ReactGrid detects focus loss and exits edit mode",
          "solution": "Use static class member Map to store pending selections, avoid React state updates entirely during editing",
          "implementation": {
            "static_pendingSelections": "Map<string, MultiSelectOption[]> on MultiSelectCellTemplate class",
            "key_format": "cellKey based on value_text_endpoint, same as editingCells Set",
            "force_update_pattern": "Use dummy state counter [, forceUpdate] = useState(0) and call forceUpdate(prev => prev + 1) after Map updates",
            "no_redux_until_commit": "handleSelect and handleRemove ONLY update static Map, never call onCellChanged",
            "final_commit_on_enter": "handleKeyDown for Enter reads from static Map, creates final cell, commits to Redux with onCellChanged(cell, true)"
          },
          "memory_management": {
            "initialize_on_entry": "handleKeyDown Enter entry clears pendingSelections.delete(cellKey) to remove stale data",
            "cleanup_on_exit": "handleKeyDown Enter/Escape exit removes from both editingCells Set and pendingSelections Map",
            "cleanup_on_clear": "DELETE/BACKSPACE also cleans up both Set and Map"
          },
          "rationale": "From contextual memory stage1_031: 'The template system is stateless - any state tracking must be done via static class members or external stores' and 'ReactGrid's architecture is event-driven and focus-based, not state-based - work with its patterns, not against them'"
        },
        
        "chip_ui_patterns": {
          "display_location": "Chips displayed at top of dropdown in a Box with flexWrap",
          "chip_removal": "MUI Chip component with onDelete handler calling handleRemove(option)",
          "capture_phase_protection": "Chip container and individual chips need onPointerDownCapture to prevent focus loss",
          "styling": "Blue chips (#1976d2) with white text to match application theme",
          "filtering_available_options": "Filter displayed options to exclude already-selected items using getSelectedOptions()"
        },
        
        "state_access_pattern": {
          "getSelectedOptions_helper": "useCallback function that checks isInEditMode and reads from static Map if editing, else derives from cell.value and options",
          "why_helper_needed": "Provides single source of truth for selected options across render, avoids duplicate logic",
          "usage_points": [
            "Rendering chips: getSelectedOptions().map()",
            "Filtering available options: options.filter(opt => !getSelectedOptions().find(...))",
            "Getting count: getSelectedOptions().length"
          ]
        },
        
        "initialization_flow": {
          "step_1": "User opens editor (Enter/double-click) -> handleKeyDown adds to editingCells, clears stale pendingSelections",
          "step_2": "useEffect detects isInEditMode, calls loadOptions('')",
          "step_3": "If cell has existing values, wait for options to load",
          "step_4": "Second useEffect detects options loaded + cell.value exists -> populate pendingSelections from cell.value filtered through options",
          "step_5": "forceUpdate triggers re-render, chips appear in dropdown"
        },
        
        "interaction_flow": {
          "add_chip": "User clicks option -> handleSelect -> update static Map -> forceUpdate -> chips re-render -> editor stays open",
          "remove_chip": "User clicks X on chip -> handleRemove -> update static Map -> forceUpdate -> chips re-render -> editor stays open",
          "commit_enter": "User presses Enter in search field -> TextField.onKeyDown intercepts -> calls handleKeyDown -> reads static Map -> creates final cell -> onCellChanged(cell, true) -> commits to Redux -> blur inputs -> editor closes",
          "cancel_escape": "User presses Escape in search field -> TextField.onKeyDown cleans up static Map/Set -> blurs search input -> lets Escape propagate to ReactGrid -> ReactGrid template handleKeyDown returns enableEditMode:false -> editor closes",
          "focus_maintained": "searchInputRef has autoFocus and maintains focus throughout add/remove operations, ReactGrid never detects focus loss during chip operations"
        },
        
        "keyboard_event_handling": {
          "problem": "Search TextField has focus (not transparent inputRef), so Enter/Escape events need special handling",
          "enter_key_solution": {
            "approach": "TextField.onKeyDown intercepts Enter, prevents default, stops propagation, manually calls parent handleKeyDown",
            "reason": "Enter must commit changes by reading from static Map and calling onCellChanged, then blur to exit edit mode",
            "implementation": "if (e.key === 'Enter') { e.preventDefault(); e.stopPropagation(); handleKeyDown(e); }"
          },
          "escape_key_solution": {
            "approach": "TextField.onKeyDown cleans up static state, blurs search input, but DOES NOT preventDefault or stopPropagation",
            "reason": "Must let Escape bubble to ReactGrid's template handleKeyDown so it can return enableEditMode:false",
            "implementation": "if (e.key === 'Escape') { /* cleanup */ searchInputRef.current.blur(); /* NO preventDefault/stopPropagation */ }",
            "critical_insight": "Preventing Escape propagation breaks ReactGrid's edit mode exit - ReactGrid needs to see the Escape keyCode to exit properly"
          },
          "typing_keys": "Non-navigation keys call e.stopPropagation() so they work in search field without triggering ReactGrid navigation",
          "arrow_keys": "Arrow keys allowed to propagate for dropdown navigation within MenuList"
        },
        
        "validation_integration_specifics": {
          "invalid_paste_detection": "When text pasted into multiselect cell, value is null but text is not empty - indicates arbitrary text pasted, not valid ID array",
          "array_format_check": "Value must be array or null - if not array, immediately mark as invalid without backend call",
          "validation_short_circuit": "Check for null value + non-empty text BEFORE originalValue comparison, also check array format",
          "error_messages": {
            "invalid_paste": "Invalid multiselect value. Please select from dropdown.",
            "invalid_format": "Invalid multiselect value format."
          },
          "validation_order_criticality": "Must check multiselect-specific invalid states (paste detection, array format) before short-circuit comparison",
          "array_comparison_for_short_circuit": {
            "problem": "Arrays need deep comparison - [1,2,3] === [1,2,3] is false in JavaScript",
            "solution": "Sort both arrays and compare JSON.stringify results",
            "implementation": "const sortedNew = [...newValue].sort((a, b) => a - b); const sortedOrig = [...originalValue].sort((a, b) => a - b); valuesAreEqual = JSON.stringify(sortedNew) === JSON.stringify(sortedOrig);",
            "why_sort": "User might select items in different order than DB stored them - [1,2,3] and [3,1,2] should be considered equal",
            "handles_null": "Check if both are arrays before attempting comparison, fallback to simple equality for non-arrays"
          }
        },
        
        "copy_paste_intelligence": {
          "valid_cell_copy": "Copying multiselect cell with valid ID array and pasting to another row works - value + text preserved",
          "invalid_text_paste": "Pasting arbitrary text (e.g., from text column) triggers validation error immediately - value is null, text is not empty",
          "spreadsheet_grid_detection": "handleChanges checks if text change occurred on multiselect column, passes null value for validation (similar to relationship cells)",
          "array_preservation": "When copying/pasting valid multiselect cells, array structure is preserved through cell.value"
        },
        
        "debugging_insights": {
          "symptom_1": "Editor closing after each chip add/remove even with NO onCellChanged calls",
          "root_cause_1": "React state updates (setSelectedOptions) causing re-renders that temporarily break focus",
          "symptom_2": "After fixing focus with static Map, Enter worked but values disappeared on commit",
          "root_cause_2": "TextField has focus (not transparent inputRef), so Enter keyDown handler wasn't being called - needed to intercept in TextField.onKeyDown",
          "symptom_3": "After fixing Enter, Escape did cleanup but editor didn't close",
          "root_cause_3": "TextField.onKeyDown was calling preventDefault/stopPropagation on Escape, preventing ReactGrid from seeing it and exiting edit mode",
          "failed_attempts": [
            "Attempt 1: commit=false in handleSelect/handleRemove - editor stayed open but values lost on reopen",
            "Attempt 2: commit=true in handleSelect/handleRemove - values saved but editor closed",
            "Attempt 3: commit=true + manual editingCells Set update - still closed, worse performance",
            "Attempt 4: Local state only, no Redux - STILL CLOSED revealing React re-render as culprit",
            "Attempt 5: Static Map fixed focus, but Enter didn't commit - search field had focus, needed TextField.onKeyDown",
            "Attempt 6: Enter fixed with TextField.onKeyDown, but Escape didn't close - was blocking propagation to ReactGrid"
          ],
          "successful_solution": "Static class member for selections (prevents re-render focus loss) + TextField.onKeyDown for Enter (intercept and handle) + TextField.onKeyDown for Escape (cleanup but let propagate)"
        },
        
        "performance_characteristics": {
          "no_redux_churn": "Redux only updated once on Enter, not on every chip add/remove",
          "minimal_re_renders": "forceUpdate only triggers re-render of MultiSelectCellView, not entire grid",
          "no_console_logs": "All debug logging removed for production performance",
          "memory_cleanup": "Static Map entries cleaned up on exit, no memory leaks",
          "react_memo_optimization": {
            "component_memoization": "MultiSelectCellView wrapped in React.memo with custom comparison function",
            "comparison_logic": "Only re-renders if isInEditMode, cell.value, cell.text, validationState, isEdited, or relationshipEndpoint actually change",
            "why_custom_comparison": "Cell object is new reference on every grid update, but values might not change - custom comparison prevents unnecessary re-renders",
            "benefit": "When user types in different cell, MultiSelectCells don't re-render unnecessarily"
          },
          "useMemo_for_cellKey": {
            "implementation": "cellKey calculated with useMemo([cell.value, cell.text, cell.relationshipEndpoint])",
            "why_needed": "cellKey used in multiple places (getSelectedOptions, handleSelect, handleRemove) - memoization prevents recalculation on every render",
            "impact": "Small but measurable - string concatenation on every render adds up with many cells"
          },
          "useCallback_for_callbacks": {
            "loadOptions": "Memoized with useCallback to prevent recreation on every render",
            "getSelectedOptions": "Memoized with useCallback, dependencies include cellKey",
            "impact": "Prevents child components from re-rendering due to new function references"
          },
          "api_call_optimization": {
            "debounced_search": "300ms debounce on search query changes prevents excessive API calls",
            "no_caching_yet": "Options loaded fresh each time dropdown opens - future optimization: add TTL cache",
            "page_size_limit": "page_size=50 param limits result set for faster response"
          }
        },
        
        "future_multi_action_cells": {
          "applicability": "This pattern applies to ANY cell type requiring multiple user actions before commit",
          "examples": "Date range picker, tag editor, color palette selector, file uploader",
          "template_code": "MultiSelectCell serves as reference implementation for future multi-action cells",
          "key_principle": "If user needs to perform multiple actions in one edit session, use static class member storage, not React state"
        },
        
        "confidence_level": "high",
        "status": "documented"
      },
      
      "date_cell_patterns": {
        "decision_id": "stage1_034",
        "content": "Patterns specific to DateCell (flexible date input) integrating Stage 0 date handling with Stage 1 batch editing",
        "added_date": "2025-10-19",
        "source": "DateCell implementation (Phase 4.4)",
        "builds_on": "Stage 0 date field implementation (EditableTextField + DateInterpretationFeedback + DateFormatHelp) and Stage 1 custom cell foundation (stage1_024-031)",
        "architectural_integration": "Combines Stage 0's flexible date handling philosophy with Stage 1's ReactGrid cell architecture",
        
        "stage_0_heritage": {
          "existing_system": "Stage 0 established flexible date input for cultural archive needs (ItemDetail, CollaboratorDetail, CollectionDetail)",
          "key_components": {
            "EditableTextField": "Simple text input (no date picker) for maximum flexibility",
            "DateInterpretationFeedback": "Real-time feedback showing what will happen to user input on save (green check, blue arrow, gray question)",
            "DateFormatHelp": "Chip-based format examples (2023, 2023/03, 2023/03/15, ranges, etc.)",
            "dateStandardization.ts": "Frontend logic that mirrors backend date transformation (interpretDateInput, standardizeDateFormat)"
          },
          "validation_architecture": "Two-layer system: Frontend prediction (non-blocking real-time feedback) + Backend transformation (authoritative DRF serializer validation)",
          "backend_mirror": "frontend/src/utils/dateStandardization.ts exactly mirrors app/metadata/signals.py standardize_date_format() for accurate preview",
          "accepted_formats": [
            "Years: 2023, 1990s, 1990s?, 2020-2025",
            "Months: 2023/03, March 2023, 3/2023",
            "Full Dates: 2023/03/15, 3/15/2023",
            "Date Ranges: 2020/03-2023/10, 1/2020-3/2021, 2020-2023",
            "Approximate: ca 2023, 19th century, early 2020s",
            "Partial/Uncertain: 2023?, Spring 2023, circa 1950"
          ],
          "transformation_behavior": "American format (MM/DD/YYYY) automatically converted to standard format (YYYY/MM/DD) on save, approximate/text dates preserved as-is",
          "cultural_archive_rationale": "Flexibility required for historical dates (uncertain, approximate, partial dates common in archival materials)"
        },
        
        "stage_1_adaptation": {
          "cell_architecture": "DateCellTemplate + DateCellView following established ReactGrid patterns",
          "no_date_picker": "Plain text input maintained (NOT Material-UI DatePicker) to preserve Stage 0 flexibility",
          "dropdown_panel_design": {
            "trigger": "Edit mode automatically opens dropdown panel below cell",
            "content": [
              "DateInterpretationFeedback - Real-time preview of standardization",
              "DateFormatHelp - Chip examples of accepted formats"
            ],
            "positioning": "Absolute positioned below cell (same as SelectCell/RelationshipCell dropdowns)",
            "z_index": "10000 to appear above grid",
            "border_styling": "2px solid #1976d2 to match application theme"
          },
          "transparent_input_pattern": "Uses established pattern: transparent input maintains ReactGrid focus, Material-UI TextField provides actual UI",
          "focus_management": "TextField has autoFocus, transparent input maintains ReactGrid's focus tracking"
        },
        
        "real_time_interpretation": {
          "implementation": "useMemo(() => interpretDateInput(inputValue), [inputValue])",
          "feedback_display": {
            "preferred_format": "Green CheckCircleIcon + 'Already in preferred format' (e.g., 2023, 2023/03/15)",
            "convertible": "Blue ArrowForwardIcon + 'Will become \"2023/03/15\" on save' (shows exact conversion)",
            "unrecognized": "Gray HelpOutlineIcon + 'Format not recognized - will be saved as-is' (approximate dates)",
            "empty": "No feedback shown for empty input"
          },
          "background_color": {
            "preferred": "success.light (#e8f5e9)",
            "convertible": "info.light (#e3f2fd)",
            "unrecognized": "grey.100"
          },
          "integration_point": "Feedback shown in dropdown panel above DateFormatHelp, updates on every keystroke"
        },
        
        "format_help_display": {
          "location": "Bottom of dropdown panel (below DateInterpretationFeedback)",
          "chip_examples": ["2023", "2023/03", "2023/03/15", "03/15/2023", "2020-2023", "2023/03-2024/05"],
          "helper_text": "American format (MM/DD/YYYY) will be converted to standard format (YYYY/MM/DD) when saved. Approximate dates (e.g., \"circa 1950\", \"1990s?\") are also accepted.",
          "styling": "Caption typography, chip variant outlined, grey text for note"
        },
        
        "keyboard_event_handling": {
          "enter_key": {
            "approach": "TextField.onKeyDown intercepts Enter, prevents default, stops propagation, calls handleCommit",
            "reason": "Commits current inputValue to Redux, then blurs to exit edit mode",
            "implementation": "if (e.key === 'Enter') { e.preventDefault(); e.stopPropagation(); handleCommit(); }",
            "commit_logic": "Creates DateCell with value=inputValue, text=inputValue, calls onCellChanged(cell, true)"
          },
          "escape_key": {
            "approach": "TextField.onKeyDown cleans up static state, blurs inputs, DOES NOT preventDefault or stopPropagation",
            "reason": "Must let Escape bubble to ReactGrid's template handleKeyDown for proper edit mode exit",
            "implementation": "if (e.key === 'Escape') { editingCells.delete(cellKey); setDropdownOpen(false); textFieldRef.current.blur(); /* NO preventDefault */ }",
            "critical_insight": "Preventing Escape propagation breaks ReactGrid - learned from MultiSelectCell debugging"
          },
          "delete_backspace": "Template handleKeyDown clears cell value and exits edit mode (standard pattern)"
        },
        
        "validation_integration": {
          "cell_level": "validationState ('valid', 'invalid', 'validating') controls background color (red/blue/yellow)",
          "backend_validation": "DRF serializer's validate_<field_name> methods call standardize_date_format() on save",
          "no_blocking_validation": "Frontend interpretation is informative only, does NOT prevent saving (flexibility for edge cases)",
          "error_display": "validationError shown if backend rejects date format",
          "isEdited_tracking": "Yellow background for edited-but-not-saved cells"
        },
        
        "performance_characteristics": {
          "react_memo_optimization": {
            "component_memoization": "DateCellView wrapped in React.memo with custom comparison function",
            "comparison_logic": "Only re-renders if isInEditMode, cell.value, cell.text, validationState, or isEdited actually change",
            "benefit": "When user types in different cell, DateCells don't re-render unnecessarily"
          },
          "useMemo_for_cellKey": {
            "implementation": "cellKey calculated with useMemo([cell.value, cell.text])",
            "why_needed": "cellKey used in Escape handler and static Set operations",
            "impact": "Prevents unnecessary string concatenation on every render"
          },
          "useMemo_for_interpretation": {
            "implementation": "interpretation = useMemo(() => interpretDateInput(inputValue), [inputValue])",
            "why_needed": "interpretDateInput runs regex matching - memoization prevents recalculation unless input changes",
            "impact": "Significant performance gain when dropdown is open and user hasn't typed (prevents re-running regex on every render)"
          },
          "no_api_calls": "DateCell is fully client-side - no API calls, no debouncing needed"
        },
        
        "static_editingCells_pattern": {
          "usage": "Same as SelectCell/RelationshipCell - static Set tracks which cells are in edit mode",
          "initialization": "handleKeyDown adds to Set on Enter/double-click",
          "cleanup": "handleKeyDown removes from Set on Escape, TextField.onKeyDown removes on Escape (before propagation)",
          "purpose": "Prevents stuck-in-edit-mode bugs, enables proper Enter/Escape handling"
        },
        
        "display_mode": {
          "rendering": "Plain text div with cell.text || ''",
          "background_color": "getCellBackgroundColor() based on validationState and isEdited",
          "no_special_formatting": "Shows raw date string as-is (Stage 0 pattern - no frontend transformation)"
        },
        
        "edit_mode": {
          "rendering": "TextField with placeholder 'e.g., 2023, 2023/03/15, circa 1950'",
          "input_value_state": "Local state for inputValue, initialized from cell.value on edit mode entry",
          "dropdown_panel": "Automatically opens on edit mode entry, shows interpretation + format help",
          "material_ui_textfield": "Variant standard, disableUnderline, custom styling for height/padding match",
          "capture_phase_protection": "onPointerDownCapture and onClickCapture on TextField and dropdown to prevent ReactGrid focus loss"
        },
        
        "model_applicability": {
          "languoid_model": "No date fields (DateCell not needed for current Languoid batch editing)",
          "item_model": "Multiple date fields: creation_date, accession_date, collection_date, deposit_date, cataloged_date",
          "collection_model": "date_range_min, date_range_max (may need DateCell when Collection batch editing is implemented)",
          "collaborator_model": "birthdate, deathdate (DateCell ready for Collaborator batch editing)",
          "document_model": "creation_date (DateCell ready for Document batch editing)",
          "readiness": "DateCell is fully implemented and ready for future batch editors (Item, Collection, Collaborator, Document)"
        },
        
        "future_enhancements": {
          "date_range_cells": "Could extend DateCell to support date ranges with two inputs (start-end)",
          "calendar_picker_option": "Optional calendar icon that opens picker for users who prefer visual selection (while keeping text input as primary)",
          "smart_suggestions": "Could suggest date corrections based on common typos or format issues",
          "batch_date_operations": "Fill down could intelligently increment dates (e.g., 2023 -> 2024 -> 2025)"
        },
        
        "lessons_learned": {
          "stage_0_patterns_are_proven": "Stage 0's flexible date handling works well - no need to reinvent with date pickers",
          "frontend_backend_mirroring": "Mirroring backend logic in frontend enables accurate real-time previews",
          "cultural_archive_flexibility": "Text input flexibility is REQUIREMENT not limitation - approximate/uncertain dates are common",
          "keyboard_event_propagation": "MultiSelectCell's Escape propagation lesson applies here - don't block ReactGrid events",
          "performance_from_start": "React.memo and useMemo applied from beginning (lesson from earlier cells)"
        },
        
        "confidence_level": "high",
        "status": "documented"
      },
      
      "decimal_cell_patterns": {
        "decision_id": "stage1_037",
        "content": "Patterns specific to DecimalCell (decimal number fields with validation)",
        "added_date": "2025-10-20",
        "updated_date": "2025-10-20",
        "source": "DecimalCell implementation (Phase 4.7) - final working version",
        "builds_on": "SelectCell and RelationshipCell patterns (plain HTML input, not Material-UI)",
        "architectural_simplicity": "Plain HTML input with validation - matches established custom cell patterns",
        
        "critical_lesson": {
          "mistake": "Initially tried to use Material-UI TextField which added wrapper divs with spacing, causing positioning offset",
          "discovery": "SelectCell and RelationshipCell use plain HTML <input> elements, not Material-UI components",
          "solution": "Switched to plain HTML input matching exact pattern from SelectCell/RelationshipCell",
          "key_insight": "User wanted simple VISUAL appearance, not simple technical implementation. Use proven patterns with simple styling."
        },
        
        "use_case": {
          "decimal_fields": "Django DecimalField with high precision for coordinates and measurements",
          "example_fields": [
            "Languoid.longitude (DecimalField max_digits=22, decimal_places=16)",
            "Languoid.latitude (DecimalField max_digits=22, decimal_places=16)",
            "Geographic.lat (DecimalField max_digits=22, decimal_places=16)",
            "Geographic.long (DecimalField max_digits=22, decimal_places=16)",
            "Any decimal numeric measurements"
          ],
          "validation_requirements": [
            "Must be valid decimal number format",
            "Can be positive or negative",
            "Can be integer or decimal (e.g., 42, 42.5, -122.419906)",
            "Empty/blank is valid (nullable fields)",
            "Invalid: letters, special characters (except minus sign and decimal point)"
          ]
        },
        
        "plain_html_input_architecture": {
          "rationale": "Matches SelectCell/RelationshipCell pattern exactly - plain HTML input, no Material-UI",
          "no_material_ui": "TextField component adds wrapper divs with default spacing - causes positioning issues",
          "structure": {
            "container_div": "position: relative, with onPointerDown to stopPropagation",
            "transparent_input": "Opacity 0, maintains ReactGrid focus, handles keyboard events",
            "visible_input": "Plain HTML <input type='text'>, fills cell with width/height 100%, transparent background"
          },
          "styling": {
            "width": "100%",
            "height": "100%",
            "border": "none",
            "outline": "none",
            "background": "transparent",
            "padding": "0 8px",
            "fontSize": "14px",
            "fontFamily": "inherit",
            "margin": "0",
            "boxSizing": "border-box"
          },
          "visual_result": "Looks exactly like simple text cell - no borders, no underlines, just text"
        },
        
        "template_handleKeyDown_pattern": {
          "matches_selectcell": "Uses exact same pattern as SelectCell for keyboard handling",
          "enter_when_editing": {
            "check": "if (keyCode === ENTER && editingCells.has(cellKey))",
            "action": "Remove from Set and return enableEditMode: false",
            "purpose": "Prevents editor from re-opening after commit (this was causing double-enter bug)"
          },
          "double_click_support": {
            "check": "keyCode === POINTER_EVENT (1)",
            "action": "Add to Set and return enableEditMode: true",
            "purpose": "ReactGrid converts double-click to keyCode 1"
          },
          "backspace_during_edit": {
            "check": "if ((keyCode === DELETE || BACKSPACE) && !editingCells.has(cellKey))",
            "purpose": "Only clears cell when NOT in edit mode, during edit Backspace works normally for character deletion"
          },
          "escape_handling": "Remove from Set and return enableEditMode: false",
          "getCellKey_helper": "Private method returns consistent cellKey format"
        },
        
        "validation_logic": {
          "client_side_validation": {
            "pattern": "Regex check: /^-?\\d+\\.?\\d*$|^-?\\d*\\.\\d+$/ for complete numbers on commit",
            "validation_timing": "Only validates on commit (blur/Enter), not during typing",
            "validation_triggers": [
              "onKeyDown Enter: validate and commit (preventDefault + stopPropagation)",
              "Tab: commits value and allows navigation"
            ]
          },
          "valid_formats": [
            "Empty string: '' (for nullable fields)",
            "Integers: '42', '-17', '0'",
            "Decimals: '42.5', '-122.419906', '37.7749'"
          ],
          "invalid_formats": [
            "Letters: 'abc', '42abc'",
            "Multiple decimal points: '42.5.3'",
            "Multiple minus signs: '--42'",
            "Special characters: '42¬∞', '42,500' (comma)",
            "Incomplete: '-', '.', '42.' (invalid on commit)"
          ],
          "invalid_handling": {
            "behavior": "On invalid commit, marks cell as invalid (red background) and COMMITS the invalid value",
            "user_experience": "Cell exits edit mode and displays the invalid value with red background",
            "error_display": "Tooltip on hover shows 'Invalid decimal format'",
            "rationale": "Invalid values are committed so they can be tracked, validated by backend, and corrected later"
          },
          "backend_validation": "Django DecimalField validates max_digits and decimal_places, precision constraints"
        },
        
        "keyboard_event_handling": {
          "enter_key": {
            "behavior": "Validates input, always commits (valid or invalid), exits edit mode",
            "validation_check": "Runs validation and sets validationState accordingly",
            "propagation": "preventDefault + stopPropagation to prevent ReactGrid from seeing this"
          },
          "escape_key": {
            "behavior": "Reverts to original value, exits edit mode",
            "cleanup": "Removes from editingCells Set, blurs input, resets local state",
            "propagation": "Let Escape propagate to ReactGrid for proper exit"
          },
          "tab_key": {
            "behavior": "Commits current value (valid or invalid) and moves to next cell",
            "propagation": "Let Tab propagate to ReactGrid for navigation after commit"
          }
        },
        
        "display_mode": {
          "rendering": "Plain text div showing the numeric value",
          "background_color": "getCellBackgroundColor() based on validationState and isEdited",
          "text_color": "Inherits default - NO red text for invalid state (only red background)",
          "empty_display": "Empty string shows as blank cell (standard for nullable fields)",
          "precision_display": "Shows exact string value from database (no rounding in display)",
          "error_tooltip": "Hover shows validationError message via title attribute"
        },
        
        "edit_mode": {
          "rendering": "Plain HTML input element (type='text') - no Material-UI components",
          "styling": "Inline styles matching SelectCell/RelationshipCell appearance",
          "text_color": "Inherits default - NO red text for invalid state during editing",
          "auto_focus": "Input gets autoFocus attribute",
          "background_color": "Transparent - cell container provides background",
          "placeholder": "Enter a number",
          "user_experience": "Looks and feels exactly like editing a regular text cell"
        },
        
        "component_view_patterns": {
          "state_management": "useState for currentValue, useRef for input refs",
          "no_double_commit_flag": "Not needed - event propagation properly blocked with stopPropagation",
          "useEffect_sync": "Syncs currentValue when cell.value changes from external source",
          "handleCommit": "Validates, always commits (valid or invalid), deletes from Set, blurs input",
          "handleKeyDown": "Enter (preventDefault + stopPropagation + commit), Escape (revert + blur), Tab (commit)",
          "handleChange": "Simple setState for currentValue"
        },
        
        "performance_characteristics": {
          "react_memo_optimization": {
            "component_memoization": "DecimalCellView wrapped in React.memo with custom comparison",
            "comparison_logic": "Only re-renders if isInEditMode, cell.value, validationState, or isEdited change",
            "benefit": "When user edits different cell, DecimalCells don't re-render"
          },
          "useMemo_for_cellKey": {
            "implementation": "cellKey = useMemo(() => cell.value + '_' + cell.text, [cell.value, cell.text])",
            "why_needed": "Used in Escape handler and static Set operations",
            "impact": "Prevents unnecessary string concatenation"
          },
          "no_api_calls": "Fully client-side validation - no network requests",
          "minimal_complexity": "Simple text input with regex validation - very fast"
        },
        
        "coordinate_specific_considerations": {
          "longitude_range": {
            "valid_range": "-180 to +180 degrees",
            "validation": "Client validates format, backend/API may validate range",
            "precision": "16 decimal places supports sub-millimeter accuracy"
          },
          "latitude_range": {
            "valid_range": "-90 to +90 degrees",
            "validation": "Client validates format, backend/API may validate range",
            "precision": "16 decimal places supports sub-millimeter accuracy"
          },
          "decimal_places_note": "DecimalField(max_digits=22, decimal_places=16) stores up to 6 integer digits + 16 decimal digits"
        },
        
        "model_applicability": {
          "languoid_model": "longitude, latitude (both nullable DecimalField)",
          "geographic_model": "lat, long (Geographic instances for documents/items)",
          "measurement_fields": "Any numeric measurements requiring decimal precision",
          "nullable_handling": "Supports blank=True, null=True fields (empty string commits as null)"
        },
        
        "implementation_notes": {
          "simplicity": "DecimalCell matches SelectCell/RelationshipCell patterns exactly - plain HTML input with validation",
          "no_material_ui": "Critical: Do NOT use Material-UI TextField - it adds wrapper divs that cause positioning offset",
          "plain_html_input": "Use plain <input type='text'> with inline styles - fills cell perfectly",
          "text_cell_similarity": "Intentionally designed to look exactly like ReactGrid's default text cell",
          "validation_ux": "Standard validation pattern: invalid commits show red background with invalid value visible",
          "reusable_pattern": "Can be adapted for IntegerCell, PercentageCell, etc. by adjusting validation regex",
          "debugging_lesson": "When positioning issues occur, check if Material-UI components are adding unwanted wrappers"
        },
        
        "confidence_level": "high",
        "status": "complete"
      },
      
      "boolean_cell_patterns": {
        "decision_id": "stage1_035",
        "content": "Patterns specific to BooleanCell (three-state boolean fields)",
        "added_date": "2025-10-19",
        "source": "BooleanCell implementation (Phase 4.5)",
        "builds_on": "SelectCell foundation (stage1_024-031) and Stage 0 EditableBooleanField patterns",
        "architectural_simplicity": "Simplest custom cell - essentially SelectCell with 3 fixed choices",
        
        "stage_0_heritage": {
          "existing_system": "Stage 0 EditableBooleanField for nullable boolean fields (Items, Collections, Collaborators)",
          "three_state_requirement": "Cultural archives need null state for 'unknown' or 'not applicable' boolean values",
          "value_mapping": {
            "true": "Yes",
            "false": "No",
            "null": "Not specified"
          },
          "ui_pattern": "Material-UI Select dropdown with 3 MenuItem options"
        },
        
        "stage_1_adaptation": {
          "cell_architecture": "BooleanCellTemplate + BooleanCellView following SelectCell patterns",
          "fixed_choices": "BOOLEAN_CHOICES constant with 3 options (null, true, false)",
          "value_storage": {
            "cell_value": "String ('true', 'false', or '') for ReactGrid compatibility",
            "cell_booleanValue": "Actual boolean | null for API submission",
            "cell_text": "Display text ('Yes', 'No', 'Not specified')",
            "rationale": "ReactGrid Cell interface requires string value, but API expects boolean | null"
          },
          "immediate_commit": "Single click commits value (same as SelectCell) - no multi-action needed"
        },
        
        "value_conversion_logic": {
          "getCompatibleCell_logic": "Handles both boolean and string input values, converts to proper format",
          "boolean_to_string": {
            "true": "value='true'",
            "false": "value='false'",
            "null": "value=''"
          },
          "string_to_boolean": {
            "'true'": "booleanValue=true",
            "'false'": "booleanValue=false",
            "'' or undefined": "booleanValue=null"
          },
          "text_generation": "getDisplayText() method converts boolean value to display label",
          "commit_conversion": "handleSelect converts boolean value to string for ReactGrid storage"
        },
        
        "keyboard_event_handling": {
          "enter_key": "Commits currently selected value (same as SelectCell)",
          "escape_key": "Cancels edit, removes from editingCells Set, closes dropdown",
          "arrow_up_down": "Navigate through 3 choices, preventDefault to avoid ReactGrid navigation",
          "delete_backspace": "Clears to 'Not specified' (null), removes from editingCells, exits edit mode"
        },
        
        "static_editingCells_pattern": {
          "usage": "Same as SelectCell - static Set tracks which cells are in edit mode",
          "initialization": "handleKeyDown adds to Set on Enter/double-click",
          "cleanup": "handleKeyDown removes from Set on Escape/Delete/Backspace/Enter commit",
          "purpose": "Prevents stuck-in-edit-mode bugs, enables proper Enter/Escape handling"
        },
        
        "performance_characteristics": {
          "react_memo_optimization": {
            "component_memoization": "BooleanCellView wrapped in React.memo with custom comparison function",
            "comparison_logic": "Only re-renders if isInEditMode, cell.value, cell.text, validationState, or isEdited actually change",
            "benefit": "When user types in different cell, BooleanCells don't re-render unnecessarily"
          },
          "useMemo_for_cellKey": {
            "implementation": "cellKey calculated with useMemo([cell.value, cell.text])",
            "why_needed": "cellKey used in Escape handler and static Set operations",
            "impact": "Prevents unnecessary string concatenation on every render"
          },
          "no_api_calls": "BooleanCell is fully client-side - no API calls, no loading states",
          "minimal_complexity": "Simplest custom cell type - good template for future simple dropdown cells"
        },
        
        "display_mode": {
          "rendering": "Plain text div with cell.text (Yes/No/Not specified)",
          "background_color": "getCellBackgroundColor() based on validationState and isEdited",
          "no_special_formatting": "Shows text label directly"
        },
        
        "edit_mode": {
          "rendering": "Transparent input + dropdown menu with 3 choices",
          "dropdown_height": "maxHeight: 150px (shorter than SelectCell since only 3 options)",
          "choice_order": ["Not specified (null)", "Yes (true)", "No (false)"],
          "immediate_commit": "Click on choice commits immediately and closes editor",
          "capture_phase_protection": "onPointerDownCapture and onClickCapture to prevent ReactGrid focus loss"
        },
        
        "model_applicability": {
          "languoid_model": "No boolean fields currently",
          "item_model": "permission_to_publish_online (three-state boolean)",
          "collection_model": "expecting_additions (three-state boolean)",
          "collaborator_model": "anonymous (three-state boolean)",
          "common_pattern": "Many nullable boolean fields in cultural archives represent 'unknown' rather than false"
        },
        
        "validation_integration": {
          "cell_level": "validationState controls background color (red/blue/yellow)",
          "backend_validation": "Django model BooleanField(null=True, blank=True) accepts boolean | null",
          "no_special_validation": "Boolean values are inherently valid - no format validation needed",
          "isEdited_tracking": "Yellow background for edited-but-not-saved cells"
        },
        
        "comparison_to_selectcell": {
          "similarities": [
            "Immediate commit on selection",
            "Transparent input pattern",
            "Static editingCells Set",
            "Dropdown positioning and styling",
            "Keyboard navigation (Enter/Escape/Arrows)",
            "Performance optimizations (React.memo, useMemo)"
          ],
          "differences": [
            "Fixed 3 choices vs. dynamic choices array",
            "Value type conversion (boolean ‚Üî string) vs. string only",
            "booleanValue property for API submission",
            "Shorter dropdown (3 items vs. variable)",
            "Cultural archive rationale (null = unknown) vs. data model choices"
          ],
          "implementation_simplicity": "BooleanCell is simplest custom cell - took ~45 minutes to implement after SelectCell patterns established"
        },
        
        "lessons_learned": {
          "reactgrid_string_requirement": "ReactGrid Cell.value must be string - add separate property for actual type",
          "stage_0_consistency": "Matching Stage 0 UI patterns (3 choices, labels) ensures user familiarity",
          "nullable_boolean_importance": "Cultural archives frequently need 'unknown' state - not just true/false",
          "selectcell_as_template": "SelectCell patterns work perfectly for fixed-choice cells like BooleanCell"
        },
        
        "confidence_level": "high",
        "status": "documented"
      },
      
      "stringarray_cell_patterns": {
        "decision_id": "stage1_036",
        "content": "Patterns specific to StringArrayCell (JSONField string arrays with tag/chip input)",
        "added_date": "2025-10-19",
        "source": "StringArrayCell implementation (Phase 4.6)",
        "builds_on": "MultiSelectCell static state patterns (stage1_033) adapted for plain text strings",
        "architectural_comparison": "Similar to MultiSelectCell but without API calls - user types plain text strings",
        
        "use_case": {
          "jsonfield_string_arrays": "Django JSONField(default=list) containing plain text strings",
          "example_fields": [
            "Languoid.alt_names - Alternative names for languages",
            "Collaborator.other_names - Other names for collaborators",
            "Any model field storing arrays of text values"
          ],
          "stage_0_limitation": "Currently edited as multiline TextField (not ideal for array structure)",
          "stage_1_improvement": "Chip-based UI makes array structure visible and editable"
        },
        
        "static_state_management": {
          "pendingArrays_map": "Map<string, string[]> stores pending string arrays during multi-action editing",
          "rationale": "Same as MultiSelectCell - React state updates would break focus during add/remove operations",
          "key_format": "JSON.stringify(cell.value)_cell.text for unique identification",
          "force_update_pattern": "useState counter triggers re-renders after Map updates without changing component state",
          "initialization": "handleKeyDown adds cellKey to editingCells, clears stale pendingArrays on Enter/double-click",
          "cleanup": "handleKeyDown removes from both editingCells Set and pendingArrays Map on Escape/Delete/Backspace"
        },
        
        "chip_ui_patterns": {
          "display_location": "Chips displayed at top of dropdown in scrollable Box (maxHeight: 120px)",
          "chip_styling": "Blue background (#1976d2), white text, white delete icon",
          "chip_removal": "MUI Chip onDelete prop calls handleRemoveString",
          "capture_phase_protection": "All chip elements need onPointerDownCapture to prevent focus loss",
          "overflow_handling": "Chips wrap with flexWrap, scrollable if many items",
          "empty_state": "No chips shown if array is empty - just input field visible"
        },
        
        "text_input_patterns": {
          "input_component": "Material-UI TextField (outlined, small) for typing new strings",
          "placeholder": "Type and press Enter to add...",
          "auto_focus": "TextField gets autoFocus when dropdown opens",
          "clear_on_add": "Input clears after successful add (setInputValue(''))",
          "enter_behavior": {
            "with_text": "Adds text as new chip (calls handleAddString)",
            "without_text": "Commits entire array and closes editor (calls handleCommit)",
            "dual_purpose": "Smart Enter key - add OR commit based on input state"
          }
        },
        
        "validation_logic": {
          "trim_whitespace": "inputValue.trim() before adding - prevents accidental spaces",
          "prevent_empty_strings": "if (trimmedValue === '') return; - silently reject empty",
          "prevent_duplicates": {
            "check": "currentStrings.some(s => s.toLowerCase() === trimmedValue.toLowerCase())",
            "case_insensitive": "Prevents \"Name\" and \"name\" from both being added",
            "silent_rejection": "Duplicate attempts are ignored without error message"
          },
          "no_backend_validation": "All validation is client-side - strings are inherently valid if non-empty",
          "array_validation": "Backend accepts any string[] - no format constraints"
        },
        
        "keyboard_event_handling": {
          "enter_key_dual_mode": {
            "with_input_text": "e.preventDefault(), e.stopPropagation(), handleAddString() adds chip",
            "with_empty_input": "e.preventDefault(), e.stopPropagation(), handleCommit() finalizes array",
            "smart_behavior": "Single Enter key serves two purposes based on context"
          },
          "escape_key": {
            "approach": "Clean up static state, blur inputs, DON'T preventDefault/stopPropagation",
            "reason": "Must let Escape bubble to ReactGrid for proper edit mode exit",
            "cleanup": "Removes from editingCells Set and pendingArrays Map before propagation"
          },
          "delete_backspace": "Template handleKeyDown clears array to empty [], removes from tracking"
        },
        
        "display_mode_logic": {
          "short_arrays": "1-2 items: comma-separated (e.g., \"Name1, Name2\")",
          "long_arrays": "3+ items: count display (e.g., \"5 items\")",
          "empty_arrays": "Empty string displayed",
          "rationale": "Prevents cell from becoming too wide with many items"
        },
        
        "static_getStrings_helper": {
          "purpose": "Single source of truth for current array state",
          "logic": "If editing and pendingArrays has key, return Map value; else return cell.value",
          "usage_points": [
            "Rendering chips: getStrings().map()",
            "Adding string: check duplicates in getStrings()",
            "Removing string: filter from getStrings()",
            "Committing: read final array from getStrings()"
          ],
          "useCallback": "Memoized with [isInEditMode, cellKey, cell.value] dependencies"
        },
        
        "performance_characteristics": {
          "react_memo_optimization": {
            "component_memoization": "StringArrayCellView wrapped in React.memo with custom comparison",
            "comparison_logic": "JSON.stringify for value comparison (arrays need deep comparison)",
            "benefit": "Prevents re-renders when user edits different cell"
          },
          "useMemo_for_cellKey": {
            "implementation": "cellKey = useMemo(() => JSON.stringify(cell.value)_cell.text, [cell.value, cell.text])",
            "why_needed": "Used in getStrings, static Map operations, multiple places",
            "json_stringify": "Necessary for array comparison in key generation"
          },
          "useCallback_for_getStrings": {
            "memoization": "Prevents recreation on every render",
            "dependencies": "[isInEditMode, cellKey, cell.value]",
            "impact": "Reduces unnecessary function recreations"
          },
          "no_api_calls": "Fully client-side - no network requests, no loading states, instant feedback",
          "no_debouncing": "No need for debouncing since no API calls"
        },
        
        "interaction_flow": {
          "add_string": "User types ‚Üí presses Enter ‚Üí handleAddString ‚Üí update static Map ‚Üí forceUpdate ‚Üí chip appears ‚Üí input clears ‚Üí editor stays open",
          "remove_string": "User clicks chip X ‚Üí handleRemoveString ‚Üí update static Map ‚Üí forceUpdate ‚Üí chip disappears ‚Üí editor stays open",
          "commit_array": "User presses Enter with empty input ‚Üí handleCommit ‚Üí read from static Map ‚Üí create final cell ‚Üí onCellChanged(cell, true) ‚Üí blur inputs ‚Üí editor closes",
          "cancel_escape": "User presses Escape ‚Üí cleanup static state ‚Üí blur inputs ‚Üí let Escape propagate ‚Üí ReactGrid closes editor",
          "focus_maintained": "TextField maintains focus throughout add/remove operations, no focus loss"
        },
        
        "model_applicability": {
          "languoid_model": "alt_names (JSONField string array)",
          "collaborator_model": "other_names (likely similar structure)",
          "item_model": "Potentially title alternatives or subject keywords if added",
          "collection_model": "Potentially collection aliases if added",
          "any_jsonfield_array": "Any model with JSONField(default=list) storing plain text strings"
        },
        
        "comparison_to_multiselectcell": {
          "similarities": [
            "Static state management (pendingSelections vs pendingArrays)",
            "Force update pattern for re-renders",
            "Multi-action editing (add/remove multiple times)",
            "Chip-based UI for displaying items",
            "Capture phase event handlers",
            "Enter for add/commit, Escape for cancel",
            "React.memo with custom comparison",
            "useMemo for cellKey and helper functions"
          ],
          "differences": [
            "No API calls (plain text vs relationship lookups)",
            "No loading states (instant vs async)",
            "User types text (no dropdown of options)",
            "Validation: duplicates/empty (vs invalid IDs)",
            "Simpler data structure (string[] vs number[])",
            "Text input instead of search autocomplete",
            "Dual Enter behavior (add vs commit based on input)"
          ],
          "implementation_time": "~60 minutes after MultiSelectCell patterns established"
        },
        
        "help_text_ux": {
          "display": "Caption text below input: \"Press Enter to add item or commit changes. Press Escape to cancel.\"",
          "purpose": "Guides users on keyboard interactions",
          "positioning": "Bottom of dropdown panel",
          "styling": "Small grey text (0.7rem)"
        },
        
        "lessons_learned": {
          "multiselectcell_as_template": "MultiSelectCell static state patterns directly applicable to other multi-action cells",
          "json_stringify_for_arrays": "Must use JSON.stringify for array comparison in cellKey and React.memo",
          "dual_enter_pattern": "Enter key can intelligently switch behavior based on input state",
          "no_api_simplification": "Without API calls, cell is much simpler - instant feedback, no loading states",
          "trimming_is_essential": "Always trim user input to prevent accidental whitespace entries",
          "case_insensitive_duplicates": "Preventing case-insensitive duplicates improves UX"
        },
        
        "future_enhancements": {
          "custom_validation": "Could add min/max length per string, regex patterns, etc.",
          "autocomplete_suggestions": "Could suggest previous values from other rows",
          "bulk_import": "Could allow pasting comma-separated list",
          "sorting": "Could add drag-to-reorder for chips",
          "categories": "Could extend to key-value pairs instead of just strings"
        },
        
        "confidence_level": "high",
        "status": "documented"
      }
    },
    
    "tanstack_implementation": {
      "migration_overview": {
        "decision_id": "stage1_046",
        "content": "Complete migration from ReactGrid to TanStack Table for 10,000+ row performance",
        "added_date": "2025-11-02",
        "conversation_reference": "Phase 6-9 TanStack migration - performance optimization, integration, undo/redo, checkbox selection",
        "migration_trigger": "ReactGrid failed with 1,000+ rows due to lack of virtualization (out-of-memory errors)",
        "production_requirement": "Must handle 10,000 rows smoothly",
        "migration_phases": [
          "Phase 1: Create base TanStackSpreadsheet component with virtualization",
          "Phase 2: Implement selection system (single cell, range, keyboard navigation)",
          "Phase 3: Implement cell editing framework for all 8 cell types",
          "Phase 4: Implement copy/paste system with TSV format",
          "Phase 5: Implement validation and dirty state indicators",
          "Phase 6: Performance optimization (remove debug logging, profiling, memoization audit)",
          "Phase 7: Integration with existing batch editor (incremental, side-by-side)",
          "Phase 8: Advanced features (undo/redo)",
          "Phase 9: Checkbox column for bulk actions (selection + save integration)"
        ],
        "migration_duration": "~3 weeks",
        "confidence_level": "high",
        "status": "completed"
      },
      
      "performance_optimizations": {
        "decision_id": "stage1_047",
        "content": "Performance strategies enabling 10,000+ row smooth operation",
        "added_date": "2025-11-02",
        "strategies": {
          "row_virtualization": {
            "library": "@tanstack/react-virtual",
            "mechanism": "Only renders visible rows (~20-30) + overscan buffer",
            "impact": "10,000 rows ‚Üí 30 DOM elements (instead of 10,000)",
            "result": "60 FPS scrolling, constant memory usage"
          },
          "cell_memoization": {
            "component": "MemoizedSpreadsheetCell with React.memo",
            "equality_function": "Custom arePropsEqual with deep property comparison",
            "impact": "Cell re-renders ONLY if value, text, or state changes",
            "result": "99%+ reduction in unnecessary re-renders"
          },
          "event_handler_memoization": {
            "mechanism": "useCallback for all event handlers",
            "impact": "Prevents cell re-renders due to handler reference changes",
            "result": "Stable references across renders"
          },
          "immer_structural_sharing": {
            "mechanism": "Redux Toolkit uses Immer for state updates",
            "impact": "Unchanged objects keep same reference (structural sharing)",
            "result": "React efficiently skips unchanged subtrees"
          }
        },
        "benchmarks": {
          "dataset": "10,000 rows, 10 columns",
          "scroll_fps": "60",
          "cell_edit_latency": "45ms",
          "selection_toggle": "8ms",
          "range_select_100": "85ms",
          "select_all_10k": "180ms",
          "undo_redo": "25-95ms",
          "paste_50_cells": "450ms"
        },
        "confidence_level": "high",
        "status": "active"
      },
      
      "cell_types_implementation": {
        "decision_id": "stage1_048",
        "content": "All cell types implemented in unified CellEditor.tsx with modal approach",
        "added_date": "2025-11-02",
        "cell_types": {
          "text": "Single-line text input (TextField), cursor at end on open",
          "decimal": "Numeric input with validation",
          "select": "Dropdown menu (Material-UI Select), commits on selection",
          "relationship": "Autocomplete with API search, keyboard navigation, clear button",
          "multiselect": "Chip-based UI with API search, stays open for multiple selections",
          "stringarray": "Chip-based UI for text strings, Enter to add, no API calls",
          "boolean": "Three-state dropdown (Yes/No/Not specified), commits immediately",
          "readonly": "No editor (display-only), grayed out styling"
        },
        "editor_pattern": {
          "trigger": "Double-click or Enter key",
          "rendering": "Modal overlay positioned at cell location",
          "commit": "Blur, Enter (for most types), or click away",
          "cancel": "Escape key",
          "focus_management": "Auto-focus on primary input element"
        },
        "lessons_from_reactgrid": {
          "simpler_architecture": "No need to fight focus management - modal approach is cleaner",
          "no_static_state": "Modal lifecycle handles state naturally, no class-level static Maps needed",
          "no_capture_phase": "Modal doesn't interfere with table event handling",
          "easier_testing": "Can test editors in isolation from grid"
        },
        "confidence_level": "high",
        "status": "active"
      },
      
      "undo_redo_system": {
        "decision_id": "stage1_049",
        "content": "Comprehensive undo/redo system with atomic batch operations",
        "added_date": "2025-11-02",
        "conversation_reference": "Phase 8 implementation",
        "architecture": {
          "redux_integration": "undoStack and redoStack in batchSpreadsheetSlice",
          "history_entry_structure": {
            "type": "single | batch",
            "changes": "Array of CellChange (rowId, fieldName, oldValue, newValue, oldText, newText, oldValidationState, oldValidationError)",
            "timestamp": "Date.now()",
            "description": "Human-readable (e.g., 'Edit Name', 'Paste 50 cells')"
          },
          "max_history": "50 actions (memory management)",
          "clearing_strategy": "Clear on successful save (clears both stacks)"
        },
        "key_capabilities": {
          "single_cell_edit": "Each cell change recorded as individual HistoryEntry",
          "batch_paste": "Multi-cell paste recorded as single atomic HistoryEntry",
          "atomic_undo": "One undo reverts entire batch paste (e.g., 50 cells)",
          "conflict_preservation": "History NOT cleared on conflicts (allows undo of conflict resolution)"
        },
        "keyboard_shortcuts": {
          "undo": "Ctrl+Z (Windows/Linux) or Cmd+Z (Mac)",
          "redo": "Ctrl+Y (Windows/Linux) or Cmd+Shift+Z (Mac)"
        },
        "ui_integration": "Toolbar buttons with tooltips, disabled when no history",
        "confidence_level": "high",
        "status": "active"
      },
      
      "checkbox_selection_system": {
        "decision_id": "stage1_050",
        "content": "Checkbox column for row selection integrated with save operation",
        "added_date": "2025-11-02",
        "conversation_reference": "Phase 9 implementation",
        "architecture": {
          "column_position": "Leftmost (before row numbers)",
          "state_management": "Redux (row.isSelected) - no performance penalty with virtualization + memoization",
          "visual_feedback": "Light blue background for selected rows (#e3f2fd)"
        },
        "capabilities": {
          "individual_selection": "Click checkbox to toggle single row",
          "range_selection": "Shift+click selects continuous range",
          "select_all": "Header checkbox with indeterminate state support",
          "clear_on_save": "Selections automatically clear after successful save"
        },
        "save_integration": {
          "selected_rows": "Save button saves only selected rows with changes",
          "no_selection": "Save button shows confirmation dialog to save all changed rows",
          "feedback": "Toolbar shows 'X selected (Y with changes)'",
          "error_handling": [
            "No changes in selected rows ‚Üí error message",
            "Validation errors in selected rows ‚Üí error message"
          ]
        },
        "redux_actions": {
          "toggleRowSelection": "Toggle single row",
          "toggleAllRowSelection": "Select/deselect all with indeterminate support",
          "selectRowRange": "Shift+click range selection",
          "clearAllSelections": "Clear all checkboxes (after save)"
        },
        "confidence_level": "high",
        "status": "active"
      },
      
      "validation_system": {
        "decision_id": "stage1_051",
        "content": "Two-tier validation system with required field enforcement and detailed error reporting",
        "added_date": "2025-11-02",
        "updated_date": "2025-11-02",
        "client_side_validation": {
          "trigger": "Immediately after cell edit or paste",
          "checks": [
            "Required fields (name, glottocode - enforced immediately for existing rows)",
            "Type checking (correct type for cell type)",
            "Format checking (valid format for type)",
            "Choice matching (select types must match choices)"
          ],
          "required_field_behavior": {
            "decision_id": "stage1_056",
            "added_date": "2025-11-02",
            "content": "Required field validation with smart draft row handling",
            "required_fields": ["name", "glottocode"],
            "existing_rows": "Required fields enforced immediately when cleared",
            "draft_rows": {
              "untouched": "Empty required fields allowed (row excluded from save anyway)",
              "first_edit": "All required fields validated when any field is edited (cascade validation)",
              "rationale": "Protects data integrity without blocking placeholder rows"
            },
            "backend_fix": "level_nal field marked blank=True (derived field set by pre_save signal, migration 0095)",
            "validation_trigger": "On cell change for existing rows, on first edit for draft rows"
          },
          "visual_feedback": "Red cell with border (#ffebee background, #f44336 border)",
          "performance": "Instant, no network calls"
        },
        "backend_validation": {
          "trigger": "After client-side passes (200-300ms debounce)",
          "checks": [
            "Uniqueness (e.g., glottocode unique)",
            "Foreign key validity (relationship IDs exist)",
            "Business rules (e.g., parent languoid rules)",
            "Field-level conflict detection (optimistic locking)"
          ],
          "visual_feedback": {
            "invalid": "Red cell (same as client-side)",
            "conflict": "Orange cell (#ffe0b2 background, #ff9800 border)"
          }
        },
        "validation_error_dialog": {
          "decision_id": "stage1_057",
          "added_date": "2025-11-02",
          "content": "Modal dialog showing detailed validation errors when save attempted",
          "rationale": "Better UX than disabled save button - users can discover what's wrong",
          "trigger": "Save button clicked with validation errors present",
          "displays": {
            "row_number": "1-indexed row number for easy navigation",
            "row_name": "Row name (truncated to 50 chars if long)",
            "errors_per_row": "All validation errors for that row (deduplicated)",
            "fallback": "Shows '(unnamed)' if name field is empty"
          },
          "features": [
            "Clear title: 'Validation Errors Prevent Saving'",
            "Row-by-row breakdown with red left border",
            "All errors listed per row (not just first)",
            "Name truncation for long names",
            "Modal prevents save until acknowledged",
            "Single OK button to dismiss"
          ],
          "design_decision": "Informative modal over disabled button - users can click Save to discover what's wrong, get specific row-level guidance"
        },
        "visual_indicators": {
          "valid": "No highlighting",
          "edited_valid": "Yellow background (#fff9c4)",
          "invalid": "Red (client or backend rejection)",
          "conflict": "Orange (concurrent edit detected)"
        },
        "conflict_detection": {
          "strategy": "Field-level optimistic locking",
          "mechanism": "Backend compares client timestamp with DB timestamp",
          "resolution": "Only conflicted fields rejected, other fields save successfully",
          "user_experience": "Orange highlighting + error message listing conflicted fields, user can review and re-save to overwrite"
        },
        "confidence_level": "high",
        "status": "active"
      },
      
      "copy_paste_system": {
        "decision_id": "stage1_052",
        "content": "TSV-based copy/paste compatible with Excel and Google Sheets",
        "added_date": "2025-11-02",
        "format": "Tab-Separated Values (TSV) for multi-cell operations",
        "capabilities": {
          "single_cell": "Copy cell.text to clipboard as plain text",
          "range": "Serialize to TSV (rows = newlines, columns = tabs)",
          "fill_behavior": "Single value ‚Üí selected range fills all cells",
          "paste_parsing": "Parse TSV and apply type-aware transformations"
        },
        "type_aware_parsing": {
          "text": "Paste as-is",
          "decimal": "Validate numeric format",
          "select": "Check against choices",
          "relationship": "Store as text, value=null (API resolution later)",
          "multiselect": "Store as text, value=null (API resolution later)",
          "stringarray": "Parse comma-separated or JSON array",
          "boolean": "Accept 'true'/'false', 'yes'/'no', '1'/'0', true/false (JSON)",
          "readonly": "Ignore paste (no-op)"
        },
        "keyboard_shortcuts": {
          "copy": "Ctrl+C (Windows/Linux) or Cmd+C (Mac)",
          "paste": "Ctrl+V (Windows/Linux) or Cmd+V (Mac)"
        },
        "undo_integration": "Batch paste recorded as single atomic undo action",
        "confidence_level": "high",
        "status": "active"
      },
      
      "keyboard_navigation": {
        "decision_id": "stage1_053",
        "content": "Full spreadsheet-style keyboard navigation including cell clearing",
        "added_date": "2025-11-02",
        "updated_date": "2025-11-02",
        "supported_keys": {
          "arrow_keys": "Navigate between cells (up/down/left/right)",
          "tab": "Move to next cell (right, then down)",
          "shift_tab": "Move to previous cell (left, then up)",
          "home": "Jump to first column in current row",
          "end": "Jump to last column in current row",
          "enter_view": "Open editor for selected cell",
          "enter_edit": "Commit changes and close editor",
          "escape": "Cancel changes and close editor",
          "delete": "Clear cell content without entering edit mode (respects readonly)",
          "backspace": "Does nothing when not in edit mode (data protection)"
        },
        "delete_key_behavior": {
          "decision_id": "stage1_055",
          "content": "Delete key clears cells, Backspace blocked for data protection",
          "added_date": "2025-11-02",
          "rationale": "Balance between productivity (single-key clear) and data protection (intentional Delete vs accidental Backspace)",
          "implementation": "Option A - Excel-compatible with protection",
          "cross_platform": {
            "windows": "Delete key clears, Backspace does nothing",
            "mac": "Fn+Delete clears (2 keys = more intentional), Delete key (backspace) does nothing"
          },
          "features": [
            "Single cell clear - clears selected cell",
            "Range clear - clears all cells in selection range",
            "Readonly protection - skips readonly cells automatically",
            "Type-aware empty values - null for text/select, [] for arrays, null for boolean",
            "Undo/redo support - single cell = 1 undo, range = batch undo",
            "Validation trigger - cleared required fields turn red immediately"
          ],
          "design_decision": "Backspace blocked to prevent accidental data loss. Users must use Delete key (more intentional). Differs from Excel/Sheets but aligns with project data integrity goals.",
          "documentation": "docs/system-behavior/batch-editor/delete-key-implementation.md",
          "confidence_level": "high",
          "status": "active"
        },
        "auto_scroll": "Selected cell always visible (scrolls into view automatically)",
        "performance": "Keyboard navigation fully functional with 10,000 rows due to virtualization",
        "confidence_level": "high",
        "status": "active"
      },
      
      "documentation": {
        "decision_id": "stage1_054",
        "content": "Comprehensive documentation in docs/system-behavior/batch-editor/",
        "added_date": "2025-11-02",
        "updated_date": "2025-11-02",
        "location": "docs/system-behavior/batch-editor/",
        "files": [
          "README.md - Overview and navigation",
          "architecture.md - Component hierarchy, state management, data flow",
          "cell-types.md - All 8 cell types with implementation details",
          "editing-features.md - Undo/redo, selection, copy/paste, validation",
          "performance.md - Benchmarks, optimizations, known limitations",
          "delete-key-implementation.md - Delete/Backspace behavior, cross-platform considerations"
        ],
        "guidelines_established": [
          "Never create root-level .md files without approval",
          "Use existing docs/ structure (deployment, development, operations, system-behavior, user-guide)",
          "Group related docs in subdirectories with README.md navigator",
          "Avoid ephemeral terminology (phase-X, sprint-Y)",
          "Consolidate before creating new docs",
          "Ask before documenting volatile features",
          "High-level historical info only in docs"
        ],
        "confidence_level": "high",
        "status": "active"
      },
      
      "bulk_import_system": {
        "decision_id": "stage1_056",
        "content": "Excel/CSV bulk import with smart row reconciliation and validation",
        "added_date": "2025-11-03",
        "conversation_reference": "Bulk import feature - Excel/CSV upload with FK resolution, duplicate detection, validation",
        "rationale": "Enable users to perform bulk ingests leveraging the batch editor's full validation suite, avoiding direct database imports that bypass validation",
        
        "feature_overview": {
          "upload_methods": [
            "Upload button (file picker dialog)",
            "Drag and drop directly onto spreadsheet"
          ],
          "supported_formats": [
            ".xlsx (Excel 2007+)",
            ".xls (Excel 97-2003)",
            ".csv (Comma-separated values)"
          ],
          "file_limits": {
            "max_file_size": "10 MB",
            "soft_row_limit": "1000 rows (warning dialog)",
            "rationale": "Balance between usability and performance/memory constraints"
          }
        },
        
        "column_mapping_strategy": {
          "algorithm": "Case-insensitive, trim whitespace, replace underscores with spaces",
          "example": "Parent_Languoid_Glottocode ‚Üí parent languoid glottocode (matches batch editor column)",
          "implementation": "frontend/src/services/importColumnMapper.ts",
          "ignore_unrecognized_columns": true,
          "ignore_derivative_columns": true,
          "critical_lesson": "ALL batch editor columns must be in IMPORT_COLUMN_MAP. Missing columns = changes not detected/applied (bug discovered during testing).",
          "complete_column_coverage": [
            "name", "name_abbrev", "glottocode", "iso",
            "level_glottolog", "alt_names", "parent_languoid",
            "region", "longitude", "latitude", "tribes", "notes"
          ]
        },
        
        "smart_row_reconciliation": {
          "decision_id": "stage1_057",
          "content": "Import determines whether to update existing DB row, modify existing spreadsheet row, or create new draft",
          "added_date": "2025-11-03",
          "priority_order": [
            "1. If glottocode matches existing DB object ‚Üí Load that object, apply spreadsheet changes to it",
            "2. If glottocode matches existing spreadsheet row ‚Üí Modify that row with spreadsheet changes",
            "3. Otherwise ‚Üí Create new draft row"
          ],
          "duplicate_detection": {
            "primary_key": "glottocode",
            "name_conflict_detection": "If new row has name matching existing languoid but no glottocode match ‚Üí Orange cell warning",
            "orange_validation": "Uses existing orange cell infrastructure (same as concurrent edit conflicts)"
          },
          "change_detection": {
            "only_apply_actual_changes": "Compare spreadsheet value to current value, only update if different",
            "comparison_logic": "Type-aware comparisons (e.g., string arrays compare as sets, ignoring order)",
            "implementation": "frontend/src/services/importValueParsers.ts::areCellValuesEqual()"
          }
        },
        
        "value_parsing_system": {
          "decision_id": "stage1_058",
          "content": "Type-aware parsing of spreadsheet cell values to batch editor cell format",
          "added_date": "2025-11-03",
          "critical_importance": "Incorrect parsing = validation errors, data loss, or failed saves",
          
          "text_fields": {
            "cell_types": ["text"],
            "parsing": "Trim whitespace",
            "empty_value": "'' (empty string)",
            "critical_lesson": "Django CharField(blank=True) expects empty string '', NOT null. Using null causes validation errors."
          },
          
          "decimal_fields": {
            "cell_types": ["decimal"],
            "parsing": "Convert to string (e.g., '42.5')",
            "storage_format": "String in both value and text fields",
            "empty_value": "'' (empty string)",
            "rationale": "Backend expects string, frontend displays string. Consistent representation."
          },
          
          "select_fields": {
            "cell_types": ["select"],
            "parsing": "Fuzzy match to choices (case-insensitive), store machine value",
            "example": "'lang' ‚Üí 'language', 'dial' ‚Üí 'dialect'",
            "display": "Use get_FIELD_display() for human-readable label",
            "empty_value": "'' (empty string)"
          },
          
          "relationship_fields": {
            "cell_types": ["relationship"],
            "parsing": "Lookup glottocode ‚Üí ID using LanguoidCache",
            "cache_strategy": "In-memory cache lookup (LanguoidCache loads all languoids at batch editor mount)",
            "value": "Foreign key ID (integer) if found, null if not",
            "text": "'Name (glottocode)' format for display",
            "empty_value": "null",
            "critical_lesson": "LanguoidCache already contains ALL languoids (page_size: 10000) in sessionStorage. No additional API calls needed for FK lookups during import."
          },
          
          "multiselect_fields": {
            "cell_types": ["multiselect"],
            "parsing": "Parse comma-separated glottocodes, lookup each ‚Üí ID using LanguoidCache",
            "value": "Array of IDs [1, 2, 3]",
            "text": "'Name1 (code1), Name2 (code2)'",
            "empty_value": "[] (empty array)",
            "future_use": "Currently no M2M fields in languoid batch editor, but pattern ready for other models"
          },
          
          "stringarray_fields": {
            "cell_types": ["stringarray"],
            "parsing": "Parse comma-separated list OR JSON array",
            "value": "Array of strings ['item1', 'item2']",
            "text": "'item1, item2' (comma-space separated)",
            "comparison": "Set-based comparison (order-independent)",
            "empty_value": "[] (empty array)",
            "critical_lesson": "Django JSONField expects array, not comma-separated string. Frontend must parse before sending to backend."
          },
          
          "implementation_files": [
            "frontend/src/services/importValueParsers.ts - Parsing and comparison logic",
            "frontend/src/services/importTransformer.ts - Row reconciliation using parsers",
            "frontend/src/contexts/LanguoidCacheContext.tsx - In-memory FK cache"
          ]
        },
        
        "import_orchestration": {
          "hook": "frontend/src/hooks/useImportSpreadsheet.ts",
          "flow": [
            "1. File validation (size, format, column recognition)",
            "2. Parse file (xlsx library)",
            "3. Transform data (smart row reconciliation + value parsing)",
            "4. Dispatch single Redux action (importSpreadsheetChanges)",
            "5. Trigger validation for all affected cells",
            "6. Auto-check all affected rows",
            "7. Auto-scroll to first affected row",
            "8. Show success/error snackbar"
          ],
          "single_undo_action": {
            "critical_decision": "Entire import = single undoable action",
            "rationale": "Users expect 'undo import' to revert ALL changes, not 250 separate undos",
            "implementation": "Redux action 'importSpreadsheetChanges' creates one HistoryEntry of type 'import'",
            "overflow_protection": "Gracefully skip history if import size > maxHistorySize (prevents memory overflow)",
            "undo_behavior": "Reverts all cell changes AND removes any draft rows that were added",
            "redo_limitation": "Currently only redoes cell changes, not full row re-addition (acceptable tradeoff)"
          },
          "validation_strategy": {
            "validate_all_immediately": "All imported cells validated on import (Option A)",
            "rationale": "Users expect full feedback after uploading a carefully prepared spreadsheet",
            "spinner_cursor": "Global spinner cursor during FK lookups and validation (no banner message)",
            "performance": "Leverages existing bulk validation infrastructure from paste operations"
          }
        },
        
        "auto_checkbox_behavior": {
          "affected_rows": [
            "New draft rows created by import",
            "Existing spreadsheet rows modified by import",
            "Existing spreadsheet rows in import file but unchanged"
          ],
          "rationale": "Makes it clear which rows were processed by import. User can easily save all imported changes by clicking Save.",
          "unchanged_rows_tracked": "ImportResult.unchangedRows array explicitly tracks these for checkbox selection"
        },
        
        "critical_debugging_lessons": {
          "missing_columns_in_mapper": {
            "symptom": "Changes to certain fields not detected or applied during import",
            "root_cause": "IMPORT_COLUMN_MAP was missing several batch editor fields (name_abbrev, region, latitude, longitude, tribes, notes)",
            "lesson": "IMPORT_COLUMN_MAP must include ALL batch editor fields. Even if not in typical exports, users may add them manually.",
            "verification": "When adding batch editor to new model, audit IMPORT_COLUMN_MAP against ALL column definitions in model-specific editor"
          },
          
          "draft_row_id_format": {
            "symptom": "400 error on save: 'Field id expected a number but got UUID'",
            "root_cause": "Backend expects draft row IDs in format 'draft-{uuid}', but import was creating plain UUIDs",
            "lesson": "Always prefix draft row IDs with 'draft-' when creating new rows",
            "implementation": "id: `draft-${uuidv4()}`"
          },
          
          "sequential_order_matching": {
            "symptom": "Saved draft rows disappeared from batch editor",
            "root_cause": "Trying to match saved languoids to draft rows by name (unreliable, especially if names normalized by backend)",
            "lesson": "Backend processes rows in order sent and returns saved objects in same order. Match by sequential order, not by name.",
            "implementation": "Iterate through editedRows and match to response.saved sequentially"
          },
          
          "partial_row_construction": {
            "symptom": "When importing existing row into empty batch editor, unchanged cells appeared yellow (edited)",
            "root_cause": "importTransformer.ts::languoidToSpreadsheetRow() only created 7 cells, missing 6 fields (name_abbrev, region, longitude, latitude, tribes, notes)",
            "lesson": "When converting DB object to SpreadsheetRow, ALL cells must be created with correct isEdited and originalValue. Missing cells ‚Üí implicitly added later with incorrect state.",
            "fix": "Ensure languoidToSpreadsheetRow creates all 13 cells matching structure from languoidToRow in model-specific editor",
            "verification": "When implementing for new model, compare cell creation in transformer to cell creation in model-specific editor"
          },
          
          "empty_value_consistency": {
            "symptom": "Empty optional text fields marked invalid after import or Delete key",
            "root_cause": "Django CharField(blank=True) expects '' for empty, but code was sending null",
            "lesson": "Empty value must match Django field expectation: '' for CharField, null for ForeignKey/Boolean, [] for JSONField",
            "two_locations_fixed": [
              "1. Delete key handler in TanStackSpreadsheet.tsx",
              "2. Default value parser in importTransformer.ts"
            ],
            "type_mapping": {
              "text/decimal/select": "'' (empty string)",
              "relationship/boolean": "null",
              "stringarray/multiselect": "[] (empty array)"
            }
          },
          
          "draft_row_isedited_logic": {
            "symptom": "Empty optional cells in new imported rows appeared yellow (edited)",
            "root_cause": "isEdited = value !== originalValue. For draft rows, originalValue = null, but empty string '' !== null",
            "lesson": "For draft rows, isEdited should be true only if value is non-empty. Empty optional fields should not be marked edited.",
            "implementation": "Redux reducer uses isEmpty() helper for draft rows",
            "haschanges_logic": "For draft rows, hasChanges = true only if ANY cell has non-empty value"
          },
          
          "celery_worker_code_caching": {
            "symptom": "Export column order changes not reflected in downloaded files",
            "root_cause": "Export handled by Celery background task. Worker process caches Python code in memory.",
            "lesson": "Changes to Celery task code require worker restart to take effect",
            "two_code_locations": [
              "1. app/internal_api/views.py - Small synchronous exports",
              "2. app/metadata/tasks.py - Large async exports (Celery)"
            ],
            "fix_procedure": "Update both files, then restart Celery worker"
          }
        },
        
        "ui_visual_feedback": {
          "drag_drop_overlay": "Visual indicator when file dragged over spreadsheet",
          "spinner_cursor": "Global cursor during import processing (file parsing, FK lookups, validation)",
          "success_snackbar": "Auto-dismiss after 5s, shows count of affected rows",
          "error_snackbar": "Auto-dismiss after 5s with close button, shows specific error",
          "smooth_fade": "Uses Material-UI Fade transition for snackbars",
          "auto_scroll": "Scrolls to first affected row (new or modified) using imperative scrollToRow() method"
        },
        
        "reusability_for_other_models": {
          "what_is_reusable": [
            "Column mapping strategy (importColumnMapper.ts)",
            "File parsing logic (fileParser.ts)",
            "Type-aware value parsers (importValueParsers.ts)",
            "Import orchestration hook pattern (useImportSpreadsheet.ts)",
            "UI components (upload button, drag/drop overlay, snackbars)",
            "Single undo action pattern",
            "Validation integration",
            "Auto-checkbox behavior"
          ],
          "what_must_be_customized": {
            "import_column_map": "Model-specific field names and mappings",
            "cache_context": "Model-specific FK lookup cache (e.g., CollaboratorCache for collaborators)",
            "row_reconciliation_key": "Model-specific unique identifier (e.g., glottocode for languoid, email for collaborator)",
            "value_parsers": "Model-specific FK lookups (but pattern remains same)",
            "languoidToSpreadsheetRow": "Model-specific DB object ‚Üí SpreadsheetRow conversion"
          },
          "implementation_checklist": [
            "1. Create IMPORT_COLUMN_MAP with ALL batch editor fields",
            "2. Implement model-specific cache with getByPrimaryKey() and getByName() methods",
            "3. Customize transformImportData() reconciliation logic for model's unique identifier",
            "4. Implement modelToSpreadsheetRow() creating ALL cells with correct isEdited/originalValue",
            "5. Test with: new rows, existing rows with changes, existing rows without changes, empty batch editor vs populated",
            "6. Verify draft row ID format ('draft-{uuid}')",
            "7. Verify empty value types match Django field expectations",
            "8. Verify sequential order matching for saved rows",
            "9. Test with Celery worker restart if export functionality affected"
          ]
        },
        
        "confidence_level": "high",
        "status": "active"
      },
      
      "validation_and_conflict_detection": {
        "decision_id": "stage1_059",
        "content": "Multi-layered validation system with real-time feedback and conflict resolution",
        "added_date": "2025-11-03",
        "conversation_reference": "Validation framework, required field validation, concurrent edit detection, field-level conflicts",
        
        "validation_layers": {
          "client_side_validation": {
            "timing": "Immediate feedback during/after cell edit",
            "purpose": "Provide instant feedback without waiting for API roundtrip",
            "rules": [
              "Required fields (name, glottocode) - cannot be empty",
              "Type checking - decimal format, valid choices for select",
              "Format checking - stringarray parsing, boolean values",
              "Self-reference prevention - languoid cannot be its own parent"
            ],
            "limitations": "Cannot validate unique constraints or complex business logic",
            "implementation": "LanguoidBatchEditor.tsx::validateCell()"
          },
          
          "backend_validation": {
            "timing": "Async after client validation passes",
            "purpose": "Database-level validation (unique constraints, complex business rules)",
            "trigger": "Debounced API call after cell edit",
            "api_endpoint": "/api/internal/batch-languoid/validate-cell/",
            "returns": "validationState ('valid'|'invalid') and validationError message",
            "performance": "Batched for multi-cell paste operations"
          },
          
          "save_time_validation": {
            "timing": "Before committing transaction to database",
            "purpose": "Final integrity check and conflict detection",
            "checks": [
              "All modified cells valid",
              "No concurrent edit conflicts (field-level optimistic locking)",
              "Required fields present",
              "Foreign key references exist"
            ],
            "rollback": "Transaction rolled back if any validation fails"
          }
        },
        
        "validation_states": {
          "valid": {
            "color": "Default (white background)",
            "description": "Cell value passed all validation checks"
          },
          "invalid": {
            "color": "Red background (#ffebee)",
            "icon": "Error icon (‚ùå) with tooltip showing error message",
            "description": "Cell value failed validation",
            "examples": [
              "Required field is empty",
              "Decimal field contains non-numeric characters",
              "Select value not in choices",
              "Languoid cannot be its own parent"
            ]
          },
          "validating": {
            "color": "Default (no special styling during validation)",
            "cursor": "Spinner cursor (global, for bulk operations)",
            "description": "Backend validation in progress",
            "performance_note": "No per-cell spinner to avoid visual noise with 10,000 rows"
          }
        },
        
        "cell_state_visual_indicators": {
          "isEdited_yellow": {
            "color": "Yellow background (#fff9c4)",
            "description": "Cell value differs from originalValue (unsaved changes)",
            "applies_to": "Existing rows only (not draft rows with empty optional fields)"
          },
          "hasConflict_orange": {
            "color": "Orange background (#ffe0b2)",
            "icon": "Warning icon (‚ö†Ô∏è) with tooltip",
            "description": "Concurrent edit detected OR name matches existing languoid",
            "user_action_required": "Review conflict, decide whether to overwrite or revert",
            "auto_resolve": "Orange clears when user edits cell again (becomes yellow)"
          },
          "priority_order": "Red (invalid) > Orange (conflict) > Yellow (edited) > White (unchanged)"
        },
        
        "required_field_validation": {
          "decision_id": "stage1_060",
          "content": "Special handling for required fields in new vs existing rows",
          "added_date": "2025-11-03",
          "required_fields": ["name", "glottocode"],
          "new_draft_rows": {
            "behavior": "Empty required fields are valid if row is untouched (hasChanges = false)",
            "rationale": "Newly added empty rows shouldn't immediately show as invalid. User hasn't interacted yet.",
            "validation_trigger": "Required field validation activates once user edits ANY cell in that row"
          },
          "existing_rows": {
            "behavior": "Required fields always validated (should never be empty for existing DB objects)",
            "assumption": "Backend enforces required constraints on save"
          },
          "save_button_behavior": {
            "disabled_if": "false (button never disabled - allow user to attempt save)",
            "validation_error_dialog": "If checked rows have hasErrors = true, show modal with detailed error list",
            "error_dialog_content": [
              "Row number",
              "Row name (for identification)",
              "List of specific field errors with messages"
            ],
            "user_experience": "Users see exactly which rows/fields are blocking save, can fix and retry"
          }
        },
        
        "concurrent_edit_detection": {
          "decision_id": "stage1_061",
          "content": "Field-level optimistic locking with partial save support",
          "added_date": "2025-11-03",
          "strategy": "Optimistic locking with conflict resolution",
          
          "how_it_works": {
            "1_load_row": "Frontend stores row._updated timestamp from DB",
            "2_user_edits": "User makes changes in Tab 1",
            "3_concurrent_edit": "Meanwhile, another user (Tab 2) edits same row and saves",
            "4_tab1_saves": "Tab 1 sends: edited cells + original _updated timestamp",
            "5_backend_check": "Backend compares _updated timestamp - if different, conflict detected",
            "6_field_level_check": "Backend determines which specific fields were edited by both tabs",
            "7_partial_save": "Non-conflicting fields are saved successfully",
            "8_conflict_response": "Backend returns: which fields had conflicts, current DB values for those fields",
            "9_frontend_update": "Frontend marks conflicting cells orange, updates other cells to saved values"
          },
          
          "field_level_conflicts": {
            "scenario_1": "Tab 1 edits field A, Tab 2 edits field B ‚Üí Both save successfully",
            "scenario_2": "Tab 1 edits field A, Tab 2 edits field A ‚Üí Tab 2's save marks field A orange (conflict)",
            "scenario_3": "Tab 1 edits A+B, Tab 2 edits B+C ‚Üí Tab 2 saves A and C, B marked orange",
            "advantage": "Maximizes successful partial saves, minimizes data loss from concurrent edits"
          },
          
          "user_resolution_flow": {
            "1_see_orange_cell": "User sees orange cell with conflict warning tooltip",
            "2_review_options": "Tooltip shows: current DB value vs their attempted value",
            "3_decide": "User decides: keep DB value (cancel edit) or overwrite (edit again)",
            "4_edit_again": "If user edits cell, it turns yellow (conflict acknowledged, attempting overwrite)",
            "5_save_again": "On next save, if no new conflict, the edit goes through"
          },
          
          "critical_implementation_details": {
            "preserve_conflict_state": "After conflict, originalValue and isEdited must be preserved so user can re-save",
            "no_premature_reload": "Don't call updateRowAfterSave() for conflict rows - would lose user's attempted edit",
            "conflict_vs_no_conflict": "Backend distinguishes: no changes at all (savedCount=0, no conflicts) vs conflicts (has_conflict=true)",
            "second_save_validation": "Second save after resolving conflict must use NEW _updated timestamp from conflict response"
          },
          
          "api_contract": {
            "request_payload": {
              "rows": [
                {
                  "id": "123",
                  "_updated": "2025-11-03T10:00:00Z",
                  "changes": {
                    "name": "New Name",
                    "level_glottolog": "language"
                  }
                }
              ]
            },
            "success_response": {
              "saved": ["List of successfully saved languoid objects"],
              "errors": [],
              "conflicts": []
            },
            "conflict_response": {
              "saved": ["List of partially saved objects (non-conflicting fields)"],
              "errors": [],
              "conflicts": [
                {
                  "id": 123,
                  "conflicting_fields": {
                    "name": {
                      "db_value": "Current DB Name",
                      "attempted_value": "New Name",
                      "last_updated": "2025-11-03T10:05:00Z"
                    }
                  },
                  "_updated": "2025-11-03T10:05:00Z"
                }
              ]
            }
          },
          
          "debugging_lessons": {
            "false_conflict_warning": {
              "symptom": "Second save after conflict shows 'has_conflict: true' even though save succeeded",
              "root_cause": "Frontend checking conflicts.length > 0 even when save was successful",
              "fix": "Only show conflict warning if response.conflicts?.length > 0 AND response is not a general error"
            },
            "no_conflict_overwrite": {
              "symptom": "Second tab's save overwrites first tab's save without warning",
              "root_cause": "Backend not checking _updated timestamp or not returning conflict",
              "fix": "Backend must compare _updated, return 409 status with conflict details"
            },
            "value_lost_after_conflict": {
              "symptom": "After conflict, user's attempted value disappears, row reloads with DB value",
              "root_cause": "Frontend calling updateRowAfterSave() for conflict rows, resetting to DB state",
              "fix": "Skip updateRowAfterSave() for conflict rows, preserve user's attempted edit"
            }
          }
        },
        
        "validation_performance": {
          "bulk_paste_optimization": {
            "problem": "Pasting 100 cells ‚Üí 100 API calls ‚Üí UI freeze",
            "solution": "Batch validation API endpoint processes multiple cells in one request",
            "visual_feedback": "Global spinner cursor (no 'Validating X cells' message - too noisy)",
            "user_experience": "User sees cursor change, knows to wait, no confusion about frozen UI"
          },
          "debouncing": {
            "single_cell_edit": "300ms debounce before API call",
            "rationale": "Avoid API call on every keystroke during typing"
          },
          "caching": {
            "validation_results": "Not currently cached (validation is fast enough)",
            "future_optimization": "Could cache validation results keyed by (fieldName, value) if performance degrades"
          }
        },
        
        "confidence_level": "high",
        "status": "active"
      },
      
      "smart_copy_paste_system": {
        "decision_id": "stage1_062",
        "content": "Intelligent copy/paste preserving machine-readable values and display text",
        "added_date": "2025-11-03",
        "conversation_reference": "Smart serialization format for complex cell types, hybrid clipboard approach",
        "problem_statement": "Standard clipboard copy/paste loses machine-readable data (IDs, arrays) and only copies display text",
        
        "clipboard_format": {
          "marker_format": "__CELL__<type>__<json>__<text>__",
          "example_relationship": "__CELL__relationship__123__\"Zaparo-Abishira (zapa1252)\"__",
          "example_multiselect": "__CELL__multiselect__[45,78]__\"Indo-European (indo1319), Sino-Tibetan (sino1245)\"__",
          "example_stringarray": "__CELL__stringarray__[\"Zaparo\",\"Kayapi\"]__\"Zaparo, Kayapi\"__",
          "example_select": "__CELL__select__\"language\"__\"Language\"__",
          "example_boolean": "__CELL__boolean__true__\"Yes\"__",
          "simple_types": "text, decimal - no special format, just copy/paste plain text"
        },
        
        "serialization_deserialization": {
          "on_copy": {
            "single_cell": "Serialize cell.value (machine) + cell.text (display) into marker format",
            "range": "Create TSV grid with each cell serialized",
            "clipboard_content": "Plain text that looks like: '__CELL__relationship__123__\"Zaparo-Abishira (zapa1252)\"__'",
            "implementation": "TanStackSpreadsheet.tsx::handleCopy()"
          },
          "on_paste": {
            "detect_format": "Check if pasted text matches marker pattern (__CELL__...)",
            "if_marker_found": "Extract type, parse JSON for value, extract text for display",
            "if_plain_text": "Use as-is for text/decimal, trigger validation for complex types",
            "implementation": "TanStackSpreadsheet.tsx::handlePaste()",
            "graceful_degradation": "External paste (from Excel) ‚Üí plain text ‚Üí validation catches invalid values"
          }
        },
        
        "benefits": {
          "internal_copy_paste": "Preserves exact machine values (IDs, arrays) for efficient batch editing",
          "external_paste_compatibility": "Plain text from Excel/CSV still works (validated, may be invalid)",
          "single_clipboard_format": "No need for separate 'internal' vs 'external' clipboards",
          "user_transparency": "Works invisibly - users just copy/paste as normal"
        },
        
        "debugging_lessons": {
          "display_text_not_preserved": {
            "symptom": "After pasting relationship, cell shows PK (123) instead of 'Name (glottocode)'",
            "root_cause": "Deserialization only returned value (ID), not text",
            "fix": "Updated marker format to include text: __CELL__<type>__<json>__<text>__"
          },
          "paste_validation_confusion": {
            "symptom": "Pasting plain text into relationship turned yellow (valid) but showed wrong data",
            "root_cause": "Plain text was stored as value, should have been null with text for later API resolution",
            "fix": "Set value=null, text=plainText for relationship/multiselect types when pasting plain text"
          }
        },
        
        "confidence_level": "high",
        "status": "active"
      },
      
      "hierarchical_sorting_system": {
        "decision_id": "stage1_063",
        "content": "Depth-first tree traversal sorting for hierarchical data display",
        "added_date": "2025-11-03",
        "conversation_reference": "Hierarchical sorting bug fix, tree traversal implementation in cache building",
        
        "problem_statement": {
          "symptom": "Batch editor showing languoids in alphabetical order, not hierarchical tree order",
          "impact": [
            "New saved rows appearing at end (after 'Z' names)",
            "Non-English characters sorting at very end",
            "No hierarchical grouping (families not grouped with their descendants)"
          ],
          "user_expectation": "Same tree order as languoid list page (true depth-first traversal)"
        },
        
        "root_cause_analysis": {
          "backend_cache_building": "app/metadata/tasks.py::build_languoid_list_cache() was using simple .order_by('name')",
          "frontend_list_page": "LanguoidsList.tsx already implemented correct tree traversal on frontend",
          "discrepancy": "Backend cache wasn't pre-sorted, frontend list page sorted client-side, batch editor used cache as-is",
          "lesson": "Sorting logic must be in ONE authoritative place (backend cache building)"
        },
        
        "correct_algorithm": {
          "description": "Depth-first tree traversal with alphabetical ordering of siblings",
          "rules": [
            "1. All children appear below their parent",
            "2. Siblings are sorted alphabetically",
            "3. Top-level nodes see ALL descendants below them before next sibling",
            "4. Result: Families grouped with all their descendants in nested order"
          ],
          "example_order": [
            "Afro-Asiatic (family)",
            "  Berber (language)",
            "    Tuareg (dialect)",
            "    Zenati (dialect)",
            "  Semitic (language)",
            "    Arabic (dialect)",
            "Indo-European (family)",
            "  Germanic (language)",
            "  Romance (language)"
          ]
        },
        
        "implementation": {
          "location": "app/metadata/tasks.py::build_languoid_list_cache()",
          "algorithm_steps": [
            "1. Build parent ‚Üí children mapping from queryset",
            "2. Find top-level nodes (parent_languoid = None)",
            "3. Sort top-level nodes alphabetically",
            "4. For each top-level node: recursively traverse children (depth-first)",
            "5. At each level: sort children alphabetically before traversal",
            "6. Append nodes to result list in traversal order"
          ],
          "code_pattern": {
            "recursive_function": "def add_node_and_descendants(node, visited)",
            "base_case": "if node.id in visited: return",
            "recursive_case": "for each child (sorted): add_node_and_descendants(child, visited)",
            "visited_set": "Prevents infinite loops from circular references"
          }
        },
        
        "cache_clearing_requirements": {
          "backend_cache": "Django cache - must clear after changing sort logic",
          "command": "cache.delete('languoid_list_full')",
          "frontend_cache": "sessionStorage - must clear in browser",
          "command": "sessionStorage.clear() in browser console",
          "both_required": "Changes not visible until both caches cleared AND server restarted",
          "celery_worker": "If export affected, restart Celery worker"
        },
        
        "reusability_for_other_models": {
          "applies_to": "Any model with self-referential foreign key (parent/child hierarchy)",
          "examples": ["Languoid (parent_languoid)", "Item (parent_item?)", "Geographic regions"],
          "customization_needed": [
            "Replace parent_languoid with model's parent field name",
            "Replace 'name' with model's display field",
            "Update cache key name"
          ],
          "pattern_is_reusable": "Exact same recursive algorithm works for any tree structure"
        },
        
        "debugging_lessons": {
          "sort_not_updating": {
            "symptom": "Code changed but batch editor still shows old sort order",
            "root_cause": "Forgot to clear Django cache AND sessionStorage",
            "fix": "Clear both caches AND restart Django server"
          },
          "partial_hierarchical_sort": {
            "symptom": "Some groups correct, but others (families) at end",
            "root_cause": "Incorrectly assumed 'all families first' was correct algorithm",
            "fix": "Clarified with user: true depth-first traversal, not grouped by level"
          }
        },
        
        "confidence_level": "high",
        "status": "active"
      },
      
      "user_guide_system": {
        "decision_id": "stage1_064",
        "content": "In-app user guide with markdown documentation and contextual help links",
        "added_date": "2025-11-03",
        "conversation_reference": "User guide implementation with single-source markdown, automated build, and info icon links",
        
        "architecture": {
          "single_source_of_truth": "/docs/user-guide/ (version controlled markdown files)",
          "build_process": "Automated copy to /frontend/public/docs/ via npm prestart/prebuild hooks",
          "runtime_loading": "React component fetches markdown files and assembles single-page view",
          "presentation": "Material-UI styled, sticky TOC sidebar, smooth scrolling to sections",
          "contextual_help": "InfoIconLink component provides deep links to specific guide sections"
        },
        
        "file_structure": {
          "principle": "Logical separation by feature area, not by implementation phase",
          "pattern": "Top-level sections for major features, subsections for model-specific details",
          "current_structure": {
            "/docs/user-guide/": [
              "getting-started.md - Overview, navigation, basic workflows",
              "editing-languoids.md - Single-edit languoid workflows and field descriptions",
              "batch-editor/ - Directory for batch editing subsections",
              "  overview.md - General batch editor features (keyboard nav, selection, validation)",
              "  languoid-batch.md - Languoid-specific batch features and import details",
              "  importing-data.md - General import guide (formats, validation, troubleshooting)",
              "  keyboard-shortcuts.md - Complete keyboard reference with cross-platform details"
            ]
          },
          "future_structure": {
            "editing-items.md": "Single-edit item workflows",
            "editing-collaborators.md": "Single-edit collaborator workflows",
            "batch-editor/item-batch.md": "Item-specific batch features",
            "batch-editor/collaborator-batch.md": "Collaborator-specific batch features"
          }
        },
        
        "organizational_principles": {
          "single_vs_batch": "Separate single-edit content from batch-edit content",
          "model_specific_sections": "Each model gets its own top-level section for single-edit AND a batch editor subsection",
          "feature_grouping": "Group by logical feature (editing, batch operations) not by model",
          "scalability": "Structure supports adding new models without reorganization",
          "avoid_duplication": "Common batch features in overview, model-specific details in subsections"
        },
        
        "content_organization_pattern": {
          "single_edit_sections": {
            "purpose": "Teach users about the data model and individual record editing",
            "location": "Top-level /docs/user-guide/editing-{model}.md",
            "content": [
              "Data model overview (What is a {Model}?)",
              "Field descriptions (all fields with types and validation)",
              "Relationships and hierarchies",
              "Validation rules",
              "Single-edit workflows (create, update, common tasks)",
              "When to use batch editing instead"
            ],
            "example": "/docs/user-guide/editing-languoids.md"
          },
          "batch_edit_sections": {
            "purpose": "Teach batch-specific features and bulk operations for each model",
            "location": "/docs/user-guide/batch-editor/{model}-batch.md",
            "content": [
              "Batch-specific features (hierarchical display, bulk operations)",
              "Importing model-specific spreadsheets (recognized columns, ignored columns)",
              "Model-specific import requirements (e.g., parent-child save order)",
              "Common batch tasks for this model",
              "Validation in batch mode",
              "Performance tips for large datasets"
            ],
            "example": "/docs/user-guide/batch-editor/languoid-batch.md"
          }
        },
        
        "build_automation": {
          "package_json_scripts": {
            "prestart": "mkdir -p public/docs && cp -r ../docs/user-guide public/docs/",
            "prebuild": "mkdir -p public/docs && cp -r ../docs/user-guide public/docs/"
          },
          "gitignore": "/frontend/public/docs/ (build artifact, not tracked)",
          "principle": "Markdown files in /docs are authoritative, /public/docs is generated",
          "workflow": "Edit markdown in /docs, run npm start or npm run build:django, files auto-copy"
        },
        
        "react_implementation": {
          "main_component": "frontend/src/pages/UserGuidePage.tsx",
          "features": [
            "Fetches all markdown files at page load",
            "Stores sections separately with IDs for anchor links",
            "Renders each section wrapped in Box with id={section.id}",
            "ReactMarkdown with custom Material-UI styled components",
            "Auto-generates TOC from h1/h2/h3 headings",
            "Smooth scroll to anchors with retry logic (ensures content rendered)",
            "Sticky sidebar TOC (hidden on mobile)",
            "scrollMarginTop: 80 to account for navigation bar"
          ],
          "section_assembly": "Each markdown file becomes a section with its own anchor ID",
          "scroll_behavior": {
            "timeout": "400ms to ensure markdown fully rendered",
            "retry_logic": "Retries scroll if element not found after initial timeout",
            "offset": "scrollMarginTop: 80px for sticky navigation clearance"
          }
        },
        
        "contextual_help_component": {
          "component": "frontend/src/components/common/InfoIconLink.tsx",
          "usage": "<InfoIconLink anchor=\"languoid-batch\" tooltip=\"Learn about batch editing languoids\" />",
          "behavior": "Opens user guide in new tab at specific section (anchor link)",
          "props": {
            "anchor": "Section ID (e.g., 'batch-editor', 'languoid-batch', 'importing-data')",
            "tooltip": "Hover text (optional, defaults to 'Learn more')",
            "size": "Icon size (optional, defaults to 'small')"
          },
          "integration_pattern": "Place info icons next to buttons/features that need explanation",
          "example_usage": "TanStackSpreadsheetWrapper places icon next to Save button, linking to batch editor guide"
        },
        
        "markdown_conventions": {
          "headings": {
            "h1": "Main section title (one per file, maps to section ID)",
            "h2": "Major subsections (appear in TOC)",
            "h3": "Minor subsections (appear in TOC)",
            "principle": "Use descriptive headings that make sense out of context (TOC shows them)"
          },
          "formatting": {
            "code_inline": "`glottocode`, `Parent Languoid`",
            "code_blocks": "Use for examples, CSV/JSON data, step-by-step workflows",
            "emphasis": "**Bold** for critical warnings, *italic* for UI elements",
            "lists": "Bullet points for features/items, numbered for sequential steps",
            "tables": "For field lists, keyboard shortcuts, comparisons"
          },
          "writing_style": {
            "voice": "Direct, instructional, friendly",
            "audience": "Museum staff with varying technical skill",
            "examples": "Always include concrete examples with real field names",
            "warnings": "Use ‚ö†Ô∏è or **Important** for critical information",
            "tips": "Use **Tip** or **Note** for helpful but optional info"
          }
        },
        
        "adding_new_sections": {
          "checklist": [
            "1. Create markdown file in appropriate location (/docs/user-guide/ or /docs/user-guide/batch-editor/)",
            "2. Follow naming convention: kebab-case (editing-languoids.md, languoid-batch.md)",
            "3. Start with clear h1 title that describes the section",
            "4. Structure content according to single-edit or batch-edit pattern",
            "5. Add section to UserGuidePage.tsx sections array with unique ID",
            "6. Test anchor links work (check scrolling behavior)",
            "7. Add InfoIconLink components in relevant UI locations",
            "8. Run npm start to trigger prestart hook (copies markdown)"
          ],
          "section_id_convention": "kebab-case matching filename without extension",
          "title_convention": "Human-readable title shown in TOC"
        },
        
        "model_specific_import_documentation": {
          "pattern": "Document recognized columns and ignored columns explicitly",
          "critical_details": [
            "Which columns are actually read (editable columns)",
            "Which columns are ignored (calculated/derivative)",
            "Special column requirements (e.g., 'Parent Languoid Glottocode' not 'Parent Languoid')",
            "Parent-child save order for hierarchical data",
            "Mixed hierarchy support (e.g., families + languages + dialects in one file)",
            "Update vs create behavior (glottocode matching)"
          ],
          "example": "docs/user-guide/batch-editor/languoid-batch.md ¬ß Importing Languoid Spreadsheets"
        },
        
        "maintenance_workflow": {
          "updating_existing_content": [
            "1. Edit markdown file in /docs/user-guide/",
            "2. Refresh browser (if dev server running, files already copied)",
            "3. If dev server not running, restart it (triggers prestart hook)"
          ],
          "adding_new_model": [
            "1. Create /docs/user-guide/editing-{model}.md (single-edit guide)",
            "2. Create /docs/user-guide/batch-editor/{model}-batch.md (batch guide)",
            "3. Add both to UserGuidePage.tsx sections array",
            "4. Add InfoIconLink to model's batch editor component",
            "5. Document model-specific import columns and requirements"
          ],
          "testing": [
            "Test anchor links from InfoIconLink components",
            "Verify TOC is generated correctly",
            "Check mobile view (TOC should hide)",
            "Test scroll behavior with hash in URL",
            "Verify markdown renders correctly (code blocks, tables, lists)"
          ]
        },
        
        "design_decisions": {
          "why_single_page": "Better UX for search (Ctrl+F), faster navigation, no page loads",
          "why_markdown": "Easy to edit, version controlled, non-technical staff can contribute",
          "why_automated_copy": "DRY principle while working within Create React App constraints",
          "why_fetch_not_import": "CRA doesn't support importing files outside src/, fetch from public/ works",
          "why_separate_sections": "Maintainable file sizes, clear ownership, parallel editing without conflicts",
          "why_material_ui_styling": "Consistent with rest of application, accessible, responsive"
        },
        
        "known_limitations": {
          "cra_constraints": "Cannot import files outside /src, must copy to /public",
          "search": "No built-in search (users must use browser Ctrl+F)",
          "versioning": "No version history in UI (use git for history)",
          "offline": "Requires markdown files in /public (won't work if not copied)",
          "images": "Would need to be in /public/docs as well (not yet implemented)"
        },
        
        "future_enhancements": {
          "full_text_search": "Add search box that filters TOC and content",
          "breadcrumbs": "Show current section hierarchy at top",
          "print_view": "CSS for printer-friendly single-page output",
          "images_diagrams": "Add visual aids for complex workflows",
          "videos": "Embed short tutorial videos for key features",
          "feedback_widget": "Allow users to report issues or suggest improvements",
          "mobile_toc": "Collapsible TOC for mobile instead of hiding"
        },
        
        "confidence_level": "high",
        "status": "active"
      }
    },
    
    "success_criteria": {
      "stage_completion": {
        "decision_id": "stage1_015",
        "content": "Stage 1 complete when smart spreadsheet fully replaces current import functionality",
        "added_date": "2025-01-04",
        "updated_date": "2025-10-17",
        "functional_requirements": [
          "Smart spreadsheet interface for all three models (Languoids: COMPLETE, Collaborators: COMPLETE, Items: PLANNED)",
          "Copy/paste batch editing with validation",
          "Spreadsheet upload integration with smart parsing",
          "Transaction-based saves with error handling",
          "Basic concurrent editing protection",
          "Three data loading modes (selected rows, upload, quick filters)",
          "Responsive design (desktop/tablet full, mobile functional)"
        ],
        "user_acceptance": "Museum staff can efficiently perform all current import/edit operations",
        "performance_requirements": "Handles typical dataset sizes without performance issues",
        "replacement_ready": "Can completely replace existing Django import functionality",
        "confidence_level": "high",
        "status": "in_progress"
      }
    },
    
    "implementation_lessons_and_protocols": {
      "collaborator_batch_editor_lessons": {
        "decision_id": "stage1_065",
        "content": "Comprehensive lessons learned from Collaborator batch editor implementation with 33-item conformance checklist",
        "added_date": "2025-11-10",
        "conversation_reference": "Complete Collaborator batch editor implementation session revealing all patterns that must be explicit for future implementations",
        
        "critical_importance": "The second batch editor implementation (Collaborator) revealed 33 specific items that were implicit in the first implementation (Languoid) but must be explicit requirements for all future implementations. These lessons prevent repeating mistakes when implementing Item and Document batch editors.",
        
        "key_lessons": {
          "architectural_patterns": [
            "Draft row initialization must reflect model-specific validity (hasChanges depends on auto-generated fields)",
            "Save logic must separate draft rows (send all values) from existing rows (send only changed values)",
            "M2M fields require explicit create() and update() methods in Django serializer",
            "ViewSets must auto-populate modified_by field in perform_create() and perform_update()",
            "Auto-scroll to new rows uses props-down state pattern with useEffect"
          ],
          
          "ux_conformance_categories": {
            "missing_features": "27 items covering layout, functionality, performance, caching, naming, M2M editors, selection, validation",
            "accessibility": "3 items covering ARIA attributes for dialogs, form controls, and checkboxes",
            "ux_messages": "3 items covering dialog messages, flow order, and focus behavior"
          },
          
          "implementation_protocol": {
            "phase_0": "Planning and model analysis",
            "phase_1": "Backend (serializer with M2M handling, ViewSet with modified_by automation, API endpoints)",
            "phase_2": "Frontend component (batch editor with correct draft row logic and save patterns)",
            "phase_3": "Caching (for fast load performance)",
            "phase_4": "Import/Export (transformers and hooks)",
            "phase_5": "Integration (routing, list page buttons, detail page URLs)",
            "phase_6": "Conformance check (all 33 items systematically verified)",
            "phase_7": "Testing (functional, performance, accessibility, cross-browser)"
          }
        },
        
        "usage_instructions": "Before implementing batch editor for ANY new model (Item, Document, etc.), read collaborator_batch_editor_lessons.json in full. Follow the implementation protocol exactly and verify all 33 conformance checklist items. This file is the authoritative reference for batch editor implementation.",
        
        "file_location": "context/development/collaborator_batch_editor_lessons.json",
        "related_files": [
          "frontend/src/components/collaborators/CollaboratorBatchEditor.tsx (reference implementation)",
          "frontend/src/components/languoids/LanguoidBatchEditor.tsx (original pattern)",
          "app/internal_api/serializers.py (M2M serializer patterns)",
          "app/internal_api/views.py (perform_create/update patterns)"
        ],
        
        "confidence_level": "high",
        "status": "active"
      },
      
      "list_page_state_persistence": {
        "decision_id": "stage1_066",
        "content": "Unified pattern for persisting filter, pagination, and selection state across navigation on all list pages",
        "added_date": "2025-11-11",
        "conversation_reference": "Implementation of usePersistedListState hook for consistent UX across Collaborator, Languoid, Item, and Collection list pages",
        
        "motivation": "Users expect their filters, page position, and selections to persist when navigating away and returning to list pages. This is especially important for batch editing workflows where users select items, navigate to batch editor, then return to list.",
        
        "implementation": {
          "reusable_hook": "frontend/src/hooks/usePersistedListState.ts",
          "storage_mechanism": "sessionStorage (persists for browser session, cleared on tab close)",
          "state_managed": [
            "filters (all filter field values specific to each model)",
            "selectedIds (Set<number> of selected item IDs)",
            "page (current page number)",
            "rowsPerPage (items per page)"
          ],
          "helper_functions": [
            "toggleSelection(id, checked) - toggle individual item selection",
            "setAllSelections(items, checked) - select/deselect all items on current page",
            "clearFilters() - reset all filters to defaults while preserving selections"
          ]
        },
        
        "usage_pattern": {
          "step_1": "Define FilterState interface with all filter fields for the model",
          "step_2": "Define DEFAULT_FILTERS constant with initial values",
          "step_3": "Call usePersistedListState hook with storage key and defaults",
          "step_4": "Destructure returned values",
          "step_5": "Use setFilters() to update filter state on field changes",
          "step_6": "Use toggleSelection() for checkbox clicks, setAllSelections() for select-all"
        },
        
        "applied_to": {
          "collaborators": "CollaboratorsList.tsx - COMPLETE",
          "languoids": "LanguoidsList.tsx - COMPLETE",
          "items": "ItemsList.tsx - COMPLETE",
          "collections": "CollectionsList.tsx - PENDING"
        },
        
        "checkbox_click_isolation": {
          "problem": "Clicking checkbox in list item row was also triggering navigation to detail page",
          "solution": "Change checkbox from onChange to onClick handler, add e.stopPropagation() to prevent event bubbling",
          "pattern": "onClick with e.stopPropagation() and manual state toggle"
        },
        
        "selection_indicator_chip": {
          "description": "Visual chip/badge showing count of selected items with clear-all icon",
          "location": "Header area, next to filter controls",
          "behavior": "Only visible when selectedIds.size > 0"
        },
        
        "confidence_level": "high",
        "status": "active"
      },
      
      "languoid_list_items_column": {
        "decision_id": "stage1_067",
        "content": "Replaced 'Children' column with 'Items' column in Languoid list view to show item associations",
        "added_date": "2025-11-11",
        
        "backend_changes": {
          "serializer_field": "item_count = serializers.SerializerMethodField()",
          "get_method": "get_item_count(obj): return obj.item_languages.count()",
          "query_optimization": "Added .prefetch_related('item_languages') to prevent N+1 queries"
        },
        
        "cache_versioning_enhancement": {
          "problem": "Frontend sessionStorage cache persisted old data structure without item_count field",
          "solution": "Implemented cache version checking in LanguoidCacheContext",
          "pattern": "Increment CACHE_VERSION when interface changes to force automatic cache refresh"
        },
        
        "confidence_level": "high",
        "status": "active"
      },
      
      "advanced_filter_improvements": {
        "decision_id": "stage1_068",
        "content": "Comprehensive filter enhancements across list pages including debouncing, empty field filters, and improved UX patterns",
        "added_date": "2025-11-11",
        
        "filter_debouncing_pattern": {
          "problem": "Text input filters caused page reloads and field blur on every keystroke",
          "solution": "Two-state filter pattern: filters (UI) and activeFilters (API) with lodash debounce 500ms"
        },
        
        "empty_field_filters": {
          "description": "Buttons to filter for records with empty/null values in specific fields",
          "ui_pattern": "Section with buttons formatted as '[FieldName]: Empty'"
        },
        
        "filter_ui_standardization": {
          "old_pattern": "Static 'Advanced Filters' header",
          "new_pattern": "Show/Hide Filters button + Clear Filters button + Active filter count chip"
        },
        
        "confidence_level": "high",
        "status": "active"
      }
    }
  }
}
