{
  "data_model_understanding": {
    "version": "1.3",
    "last_updated": "2025-11-13",
    "conversation_reference": "Collaborator model harmonization, Dialect/DialectInstance decommissioning, language relationship simplification, plus item_count annotations and first_names field label updates",
    "note": "Comprehensive documentation of Languoid, Collaborator, and deprecated models. Item and Document models updated with language relationship changes. Collection model still needs detailed analysis.",
    
    "deprecated_models": {
      "dialect": {
        "decision_id": "model_deprecated_001",
        "content": "Legacy Dialect model for dialect names - DEPRECATED and removed 2025-11-08",
        "added_date": "2025-11-08",
        "deprecation_reason": "Dialects now represented as Languoid objects with level_glottolog='dialect'",
        "removal_date": "2025-11-08",
        "migration": "0102_decommission_dialect_models.py",
        "superseded_by": "Languoid model with hierarchical parent_languoid relationships",
        "status": "deprecated"
      },
      
      "dialect_instance": {
        "decision_id": "model_deprecated_002",
        "content": "Legacy DialectInstance custom through model for M2M language relationships - DEPRECATED and removed 2025-11-08",
        "added_date": "2025-11-08",
        "deprecation_reason": [
          "Overcomplicated design with required modified_by field",
          "Made simple M2M operations complex (manual object creation, manual signal triggering)",
          "Django's default M2M through tables are simpler and sufficient"
        ],
        "removal_date": "2025-11-08",
        "migration": "0102_decommission_dialect_models.py",
        "relationships_migrated": [
          "Collaborator.native_languages ↔ Languoid",
          "Collaborator.other_languages ↔ Languoid",
          "Item.language ↔ Languoid",
          "Document.language ↔ Languoid"
        ],
        "superseded_by": "Django's auto-generated M2M through tables (e.g., metadata_collaborator_native_languages)",
        "metadata_lost": "modified_by tracking, timestamps (intentionally discarded)",
        "legacy_view_stubs": "Stub classes in app/metadata/views.py prevent errors in deprecated Django template views",
        "status": "deprecated"
      }
    },
    
    "core_entities": {
      "item": {
        "decision_id": "model_001",
        "content": "Items are catalog entries with rich metadata - core entity of the archive system",
        "added_date": "2025-01-04",
        "updated_date": "2025-11-14",
        "conversation_reference": "Browse categories auto-calculation and collection auto-assignment implementation",
        "characteristics": ["Catalog numbers", "Titles (indigenous and English)", "Access levels", "Resource types", "Creation dates", "Browse categories (auto-calculated)", "Collection (auto-assigned)"],
        "relationships": ["Has many Documents/Files", "Has many Collaborators", "Belongs to Collections"],
        "computed_fields": {
          "browse_categories": {
            "field_type": "MultiSelectField with editable=False",
            "calculation_location": "pre_save signal (update_item_date_ranges)",
            "calculation_logic": "Based on genre, resource_type, language_description_type, public_event fields",
            "categories": {
              "language_description": "grammars, specific-features, dictionaries (from language_description_type)",
              "music": "powwow, stomp-dance, hymns, other-ceremonial, for-children-music, forty-nine, hand-game, nac, war-dance, round-dance, sundance (from music_* genres)",
              "educational": "for-families, for-teachers, for-learners, for-administrators (from educational_material_* genres)",
              "texts": "interlinear-glossed-texts, literature-and-stories, conversation, religious-material, correspondence, narrative, popular-media-text (from primary-text and genres)",
              "videos": "for-children-video, events, popular-media-video (from resource_type='video' or 'audio-video' with genre/event conditions)"
            },
            "sorting": "Sorted by order in BROWSE_CATEGORY_CHOICES tuple (not alphabetically) - preserves group organization",
            "api_serialization": "SerializerMethodField with get_browse_categories() method to ensure read-only field appears in API responses",
            "migration_consistency": "Migration uses same calculation logic as signal for existing items"
          },
          "collection": {
            "field_type": "ForeignKey to Collection (nullable)",
            "assignment_location": "pre_save signal (update_item_date_ranges)",
            "assignment_logic": "Extracts 3-letter prefix from catalog_number if it matches 'ABC-' pattern, looks up Collection by collection_abbr",
            "pattern_matching": "Regex: ^([A-Za-z]{3})- matches catalog numbers like 'CAR-123', 'NAL-456'",
            "behavior": {
              "pattern_matches_and_collection_found": "Sets instance.collection to matching Collection",
              "pattern_matches_but_no_collection": "Sets instance.collection = None",
              "pattern_does_not_match": "Leaves collection unchanged (preserves existing value)"
            },
            "normalization": "Collection abbreviation normalized to uppercase for lookup",
            "error_handling": "Handles Collection.DoesNotExist and Collection.MultipleObjectsReturned gracefully"
          }
        },
        "confidence_level": "high",
        "status": "active"
      },
      
      "collaborator": {
        "decision_id": "model_002",
        "content": "Collaborators are people involved in creating or contributing to archived materials",
        "added_date": "2025-01-04",
        "updated_date": "2025-11-08",
        "conversation_reference": "Collaborator name field restructuring and language relationship simplification",
        
        "name_architecture": {
          "component_fields": {
            "first_names": "Given names (CharField) - labeled as 'First and Middle Name(s)' in frontend (no backward compatibility for old 'First Name(s)' label)",
            "nickname": "Preferred name or nickname (CharField, displayed in quotes)",
            "last_names": "Surname(s) (CharField)",
            "name_suffix": "Jr., III, etc. (CharField)",
            "other_names": "Aliases, alternative spellings (ArrayField of strings)"
          },
          "computed_field": {
            "full_name": "Auto-calculated via pre_save signal",
            "format": "first_names \"nickname\" last_names name_suffix",
            "rules": [
              "Empty fields omitted",
              "Quotes only if nickname present",
              "Extra spaces removed",
              "One-way sync (users edit components, full_name computed)",
              "Read-only in React frontend"
            ]
          },
          "display_formats": {
            "purpose": "Support different citation and sorting contexts",
            "calculated_on": "React frontend (CollaboratorDetail page)",
            "formats": [
              "Full name",
              "Full name sorted by last name",
              "First name(s) & last name(s)",
              "Last name(s), first name(s)",
              "Last name only",
              "First name only (with mononym fallback to last_names)"
            ]
          },
          "searchable_terms": "Set of all words from first_names, last_names, name_suffix, nickname, other_names",
          "anonymous_handling": "When anonymous=True, all display formats show 'Anonymous {collaborator_id}'"
        },
        
        "characteristics": [
          "Names (structured component fields + computed full_name)",
          "Anonymous flag (BooleanField, null=True for Not Specified)",
          "Birth/death dates (CharField with min/max DateField for ranges)",
          "Gender", 
          "Origin", 
          "Tribal affiliations",
          "Collaborator ID (IntegerField, unique)",
          "Slug (CharField, auto-generated from full_name via base58 encoding)",
          "UUID (auto-generated)",
          "item_count (annotated field via Count('item_collaborators') - not stored in DB)"
        ],
        
        "relationships": {
          "items": "M2M through CollaboratorRole (with role field)",
          "documents": "M2M (direct)",
          "native_languages": "M2M to Languoid (languages user speaks natively)",
          "other_languages": "M2M to Languoid (languages user knows but not natively)"
        },
        
        "display_and_export": {
          "item_count_display": {
            "description": "Number of items associated with this collaborator",
            "calculation": "Annotated via .annotate(item_count=Count('item_collaborators')) in queryset",
            "frontend_display": "Shown on collaborator list page",
            "export_column": "'# of Items' column in collaborator exports (after Full Name column)",
            "export_value": "Numeric count (not conditional like Languoid)"
          },
          "full_name_display": {
            "description": "Full name field is calculated on backend, display-only on frontend",
            "frontend_behavior": "CollaboratorCreate page shows calculated full name as read-only display, not editable field",
            "calculation_source": "Computed from first_names, nickname, last_names, name_suffix via pre_save signal"
          }
        },
        
        "list_page_filters": {
          "native_languages_contains": "CharFilter on native_languages__name (icontains lookup) - requires .distinct() on queryset",
          "other_languages_contains": "CharFilter on other_languages__name (icontains lookup) - requires .distinct() on queryset",
          "anonymous_isnull": "BooleanFilter for anonymous__isnull=True (finds 'Not Specified' values)",
          "filter_button_order": "Other Names: Empty → Anonymous: Not Specified → First & Middle: Empty → Tribal Affiliations: Empty → Native Languages: Empty → Other Languages: Empty"
        },
        
        "language_relationships": {
          "design": "Direct M2M to Languoid model (Dialect/DialectInstance decommissioned 2025-11-08)",
          "through_tables": [
            "metadata_collaborator_native_languages (Django auto-generated)",
            "metadata_collaborator_other_languages (Django auto-generated)"
          ],
          "signal_enforcement": "auto_add_parent_language_for_collaborator_dialects ensures parent languages present when dialects selected",
          "frontend_editing": "EditableMultiRelationshipField with hierarchical display and auto-add parent UX"
        },
        
        "signal_architecture": {
          "pre_save_signal": {
            "name": "compute_collaborator_derived_fields",
            "file": "app/metadata/signals.py",
            "responsibilities": [
              "Calculate full_name from component fields",
              "Standardize birthdate/deathdate to YYYY/MM/DD",
              "Generate slug from full_name using base58 encoding",
              "Detect anonymous flag changes and log warnings if collaborator has relationships",
              "Calculate birthdate_min/max and deathdate_min/max from date ranges"
            ]
          },
          "m2m_changed_signals": {
            "native_languages": "auto_add_parent_language_for_collaborator_dialects",
            "other_languages": "auto_add_parent_language_for_collaborator_dialects (same signal)",
            "logic": "Check ALL current languoids after any change, add missing parent languages for dialects",
            "triggers": "post_add, post_clear, post_remove"
          }
        },
        
        "special_considerations": [
          "Anonymous collaborators for cultural sensitivity (cannot identify individuals)",
          "Name field structure enforced via signals (no dirty data)",
          "Language hierarchy maintained automatically (dialects require parent languages)",
          "Slug generation ensures URL-friendly identifiers",
          "Computed full_name enables proper sorting and citation formatting"
        ],
        
        "confidence_level": "high",
        "status": "active"
      },
      
      "collection": {
        "decision_id": "model_003",
        "content": "Collections are organized groupings of related materials",
        "added_date": "2025-01-04",
        "characteristics": ["Collection abbreviations", "Names", "Organizational structure"],
        "relationships": ["Contains multiple Items"],
        "confidence_level": "medium",
        "status": "active"
      },
      
      "languoid": {
        "decision_id": "model_004",
        "content": "Languages with dialect information for linguistic heritage documentation, organized in a hierarchical tree structure",
        "added_date": "2025-01-04",
        "updated_date": "2025-10-29",
        "characteristics": [
          "Language names and glottocodes (external identifier)",
          "Hierarchical structure (Family → Subfamily → Language → Dialect)",
          "Level classification (level_glottolog: family/language/dialect)",
          "Derived hierarchy fields (level_nal, family_languoid, pri_subgroup_languoid, sec_subgroup_languoid)",
          "Cached descendents M2M for efficient tree queries",
          "item_count (annotated field via Count('item_languages') - not stored in DB)"
        ],
        "relationships": [
          "Related to Collaborators (native/other)",
          "Related to Documents",
          "Related to Items (via item_languages M2M)",
          "Self-referential: parent_languoid FK (tree structure)",
          "Self-referential: descendents M2M (cached for performance)"
        ],
        "display_and_export": {
          "item_count_display": {
            "description": "Number of items associated with this languoid",
            "calculation": "Annotated via .annotate(item_count=Count('item_languages')) in queryset",
            "frontend_display": "Shown on languoid list page and detail page (not for families)",
            "conditional_display": "Hidden on detail page when level_glottolog='family' using {!isFamily && ...} conditional",
            "export_column": "'# of Items' column in languoid exports (after ISO 639-3 column)",
            "export_conditional": "Blank for families instead of '0' to indicate N/A"
          }
        },
        "hierarchy_architecture": {
          "description": "Complex hierarchical system with automatic field derivation and cascading updates",
          "single_source_of_truth": "parent_languoid FK is the ONLY user-editable hierarchy field - all others are derived",
          "level_structure": {
            "level_glottolog": "User-specified classification (family/language/dialect) - determines detail page layout and available fields",
            "level_nal": "Automatically derived granular level (family/subfamily/subsubfamily/language/dialect) based on level_glottolog and parent's level_nal"
          },
          "derived_fields": {
            "name_abbrev": "Defaults to name if empty",
            "level_nal": "Derived from level_glottolog + parent's level_nal",
            "family_languoid": "FK to top-level family ancestor",
            "pri_subgroup_languoid": "FK to primary subfamily ancestor",
            "sec_subgroup_languoid": "FK to secondary subsubfamily ancestor",
            "descendents": "M2M to all descendants in subtree (cached for performance)"
          },
          "derivation_logic": {
            "family_to_subfamily_transition": "A 'family' type languoid with a 'family' parent becomes 'subfamily', with 'subfamily' parent becomes 'subsubfamily'",
            "hierarchy_fks_from_parent_chain": {
              "parent_is_family": "family_languoid = parent",
              "parent_is_subfamily": "pri_subgroup_languoid = parent, family_languoid = parent.family_languoid",
              "parent_is_subsubfamily": "sec_subgroup_languoid = parent, pri_subgroup_languoid = parent.pri_subgroup_languoid, family_languoid = parent.family_languoid",
              "parent_is_language": "Inherit all three FKs from parent (for dialects)"
            }
          },
          "level_change_rules": {
            "from_language_to_other": {
              "orphan_dialects": "Set parent_languoid = None for all dialect children",
              "discard_fields": "Clear region, longitude, latitude, tribes, notes (language-specific fields)",
              "trigger": "pre_save signal sets _needs_dialect_orphaning flag, post_save Celery task performs orphaning"
            }
          }
        },
        "signal_and_task_architecture": {
          "description": "Three-signal pattern for automatic field derivation and hierarchy maintenance",
          "pre_save_signal": {
            "name": "compute_languoid_derived_fields",
            "file": "app/metadata/signals.py",
            "responsibilities": [
              "Detect level_glottolog changes from 'language' → set _needs_dialect_orphaning flag, clear language-specific fields",
              "Detect parent_languoid changes → store _old_parent_id for descendents M2M update",
              "Derive level_nal from level_glottolog and parent",
              "Default name_abbrev to name if empty",
              "Derive hierarchy FKs (family_languoid, pri_subgroup_languoid, sec_subgroup_languoid) from parent chain"
            ],
            "timing": "BEFORE save - modifies instance fields synchronously"
          },
          "post_save_signal_1": {
            "name": "schedule_languoid_hierarchy_update",
            "file": "app/metadata/signals.py",
            "responsibilities": [
              "Extract _needs_dialect_orphaning flag from instance",
              "Extract _old_parent_id from instance (if parent changed)",
              "Schedule update_languoid_hierarchy_task (Priority 9 - highest)"
            ],
            "debouncing": "10-second cache key to prevent duplicate task scheduling",
            "timing": "AFTER save - triggers async task"
          },
          "post_save_signal_2": {
            "name": "schedule_cascading_dialect_updates",
            "file": "app/metadata/signals.py",
            "responsibilities": [
              "Schedule cascade_hierarchy_to_dialects_task for family/language hierarchy changes (Priority 5, 3-second delay)"
            ],
            "debouncing": "10-second cache key to prevent duplicate task scheduling",
            "timing": "AFTER save - triggers delayed async task"
          },
          "post_save_signal_3": {
            "name": "invalidate_languoid_list_cache",
            "file": "app/metadata/signals.py",
            "responsibilities": [
              "Invalidate Redis cache for languoid list (Priority 8)",
              "Trigger immediate cache rebuild via invalidate_and_warm_languoid_cache task"
            ],
            "timing": "AFTER save/delete - triggers cache refresh"
          },
          "celery_task_1": {
            "name": "update_languoid_hierarchy_task",
            "file": "app/metadata/tasks.py",
            "priority": 9,
            "max_retries": 3,
            "responsibilities": [
              "STEP 1: Orphan dialect children (if _needs_dialect_orphaning flag set)",
              "STEP 2: Update descendents M2M for languoid and NEW parent's ancestor chain",
              "STEP 3: Update descendents M2M for OLD parent's ancestor chain (if parent changed)"
            ],
            "critical_fix_2025_10_29": "Added STEP 3 to prevent stale descendents references in old parent chain when subtree is moved",
            "helper_functions": [
              "get_all_ancestors(languoid) → List[Languoid]: Traverses parent_languoid chain upward",
              "get_all_descendents(languoid, visited=None) → List[Languoid]: Recursively finds all children"
            ]
          },
          "celery_task_2": {
            "name": "cascade_hierarchy_to_dialects_task",
            "file": "app/metadata/tasks.py",
            "priority": 5,
            "delay": "3 seconds",
            "max_retries": 3,
            "responsibilities": [
              "Find all dialect descendants (recursively)",
              "Update their family_languoid, pri_subgroup_languoid, sec_subgroup_languoid FKs based on new parent hierarchy"
            ],
            "rationale": "Delayed task to avoid race conditions with immediate hierarchy updates"
          },
          "celery_task_3": {
            "name": "invalidate_and_warm_languoid_cache",
            "file": "app/metadata/tasks.py",
            "priority": 8,
            "responsibilities": [
              "Invalidate languoid list cache in Redis",
              "Rebuild cache immediately via warm_languoid_list_cache task"
            ]
          }
        },
        "parent_change_descendents_update": {
          "problem": "When a languoid's parent_languoid changes (moving a subtree), only the NEW parent's ancestor chain had its descendents M2M updated. The OLD parent's ancestor chain retained stale references to the moved subtree.",
          "example_bug": {
            "initial_tree": "FamilyA → SubfamilyA1 → LanguageA1a; FamilyB (empty)",
            "action": "Move LanguageA1a from SubfamilyA1 to FamilyB",
            "before_fix": "FamilyA.descendents=[SubfamilyA1, LanguageA1a] (STALE), SubfamilyA1.descendents=[LanguageA1a] (STALE), FamilyB.descendents=[LanguageA1a] (correct)",
            "after_fix": "FamilyA.descendents=[SubfamilyA1] (correct), SubfamilyA1.descendents=[] (correct), FamilyB.descendents=[LanguageA1a] (correct)"
          },
          "solution_implemented": "2025-10-29",
          "solution_steps": [
            "1. pre_save signal: When parent_languoid changes, store old parent ID in instance._old_parent_id",
            "2. post_save signal: Extract _old_parent_id and pass to Celery task as third argument",
            "3. Celery task STEP 3: If old_parent_id provided, fetch old parent, get its ancestor chain, recalculate descendents M2M for each (removing moved subtree)"
          ],
          "files_modified": [
            "app/metadata/signals.py (compute_languoid_derived_fields, schedule_languoid_hierarchy_update)",
            "app/metadata/tasks.py (update_languoid_hierarchy_task)"
          ],
          "impact": "Frontend languoid detail page Descendants Tree now correctly reflects hierarchy after parent changes. List page hierarchical display is accurate. Cache automatically invalidated/rebuilt."
        },
        "confidence_level": "high",
        "status": "active"
      },
      
      "document_file": {
        "decision_id": "model_005",
        "content": "Documents/Files are the actual digital assets associated with Items",
        "added_date": "2025-01-04",
        "characteristics": ["Filenames", "File types", "Access levels", "Durations", "Creation dates", "Technical metadata"],
        "relationships": ["Belongs to Items", "Related to Collaborators", "Related to Languages"],
        "evolution_note": "File model appears to be replacing Document model",
        "confidence_level": "high",
        "status": "active"
      }
    },
    
    "model_patterns": {
      "access_control": {
        "decision_id": "model_006",
        "content": "Multi-level access control system (1-4) implemented across Items and Documents",
        "added_date": "2025-01-04",
        "levels": ["Open Access", "Onsite viewing", "Time-limited", "Depositor-controlled"],
        "implementation": "Access level fields on relevant models",
        "confidence_level": "high",
        "status": "active"
      },
      
      "cultural_sensitivity": {
        "decision_id": "model_007",
        "content": "Anonymous flag on Collaborators indicates cultural sensitivity considerations",
        "added_date": "2025-01-04",
        "rationale": "Some contributors need anonymity for cultural or personal reasons",
        "implementation_impact": "Special handling in queries, display, and access control",
        "confidence_level": "high",
        "status": "active"
      }
    },
    
    "service_layer_patterns": {
      "collaborator_service": {
        "decision_id": "model_008",
        "content": "CollaboratorService centralizes business logic for collaborator operations",
        "added_date": "2025-01-04",
        "capabilities": ["Filtered querying with permissions", "Export functionality", "Anonymous collaborator handling"],
        "pattern": "Service layer separates business logic from views and tasks",
        "confidence_level": "high",
        "status": "active"
      }
    },
    
    "detailed_model_analysis": {
      "note": "Comprehensive model field analysis and relationship mapping to be conducted during audit phase",
      "field_mappings": {},
      "relationship_details": {},
      "constraint_analysis": {},
      "migration_history": {},
      "model_evolution_patterns": {}
    }
  }
}
